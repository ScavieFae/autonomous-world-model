<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Autonomous World Model â€” State Visualizer (Juicy)</title>
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #111827;
    --surface2: #1a2235;
    --surface-el: #1e293b;
    --border: rgba(255,255,255,0.06);
    --border-b: rgba(255,255,255,0.12);
    --text: #e2e8f0;
    --dim: #64748b;
    --p1: #22c55e;
    --p1-dim: rgba(34,197,94,0.15);
    --p1-glow: rgba(34,197,94,0.4);
    --p2: #f59e0b;
    --p2-dim: rgba(245,158,11,0.15);
    --p2-glow: rgba(245,158,11,0.4);
    --red: #f43f5e;
    --cyan: #06b6d4;
    --violet: #a78bfa;
    --mono: 'SF Mono', 'Cascadia Code', 'JetBrains Mono', Consolas, monospace;
    --body: system-ui, -apple-system, sans-serif;
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--body);
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    -webkit-font-smoothing: antialiased;
  }

  /* -- Header -- */
  .header {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 12px 20px;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
    flex-shrink: 0;
  }
  .header h1 {
    font-size: 15px;
    font-weight: 600;
    letter-spacing: -0.3px;
  }
  .header h1 span { color: var(--p1); }
  .header .tag {
    font-family: var(--mono);
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    padding: 3px 8px;
    border-radius: 4px;
    background: var(--p1-dim);
    color: var(--p1);
    border: 1px solid rgba(34,197,94,0.2);
  }
  .header .frame-counter {
    margin-left: auto;
    font-family: var(--mono);
    font-size: 13px;
    color: var(--dim);
    font-variant-numeric: tabular-nums;
  }
  .header .frame-counter b { color: var(--text); }

  /* -- Main layout -- */
  .main {
    flex: 1;
    display: flex;
    min-height: 0;
  }

  /* -- Canvas area -- */
  .canvas-area {
    flex: 1;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    background:
      radial-gradient(ellipse at 50% 100%, rgba(34,197,94,0.04) 0%, transparent 60%),
      var(--bg);
  }
  canvas {
    display: block;
    max-width: 100%;
    max-height: 100%;
  }

  /* -- Side panel -- */
  .panel {
    width: 280px;
    flex-shrink: 0;
    border-left: 1px solid var(--border);
    background: var(--surface);
    overflow-y: auto;
    display: flex;
    flex-direction: column;
  }
  .panel-section {
    padding: 16px;
    border-bottom: 1px solid var(--border);
  }
  .panel-section:last-child { border-bottom: none; }
  .panel-label {
    font-family: var(--mono);
    font-size: 9px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--dim);
    margin-bottom: 10px;
  }

  /* Player cards */
  .player-card {
    background: var(--surface2);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    border: 1px solid var(--border);
  }
  .player-card.p1 { border-left: 3px solid var(--p1); }
  .player-card.p2 { border-left: 3px solid var(--p2); }
  .pc-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  .pc-name {
    font-weight: 600;
    font-size: 13px;
  }
  .pc-char {
    font-family: var(--mono);
    font-size: 10px;
    color: var(--dim);
    margin-left: auto;
  }
  .pc-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    line-height: 1.8;
  }
  .pc-row .label { color: var(--dim); font-size: 11px; }
  .pc-row .value {
    font-family: var(--mono);
    font-size: 11px;
    font-weight: 500;
    font-variant-numeric: tabular-nums;
  }
  .pc-percent {
    font-family: var(--mono);
    font-size: 22px;
    font-weight: 700;
    font-variant-numeric: tabular-nums;
    letter-spacing: -0.5px;
  }
  .pc-percent.high { color: var(--red); }
  .pc-action {
    font-family: var(--mono);
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 3px;
    background: rgba(255,255,255,0.06);
    display: inline-block;
    margin-top: 4px;
  }
  .stocks-row {
    display: flex;
    gap: 4px;
    margin-top: 4px;
  }
  .stock-pip {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: 1px solid var(--border-b);
  }
  .stock-pip.alive.p1 { background: var(--p1); border-color: var(--p1); }
  .stock-pip.alive.p2 { background: var(--p2); border-color: var(--p2); }
  .stock-pip.dead { background: transparent; opacity: 0.3; }

  /* Data inspector */
  .inspector {
    font-family: var(--mono);
    font-size: 10px;
    line-height: 1.7;
    color: var(--dim);
  }
  .inspector .key { color: var(--cyan); }
  .inspector .val { color: var(--text); }

  /* -- Playback controls -- */
  .controls {
    flex-shrink: 0;
    padding: 10px 20px 14px;
    border-top: 1px solid var(--border);
    background: var(--surface);
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .timeline-row {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .timeline {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    border-radius: 2px;
    background: var(--surface2);
    outline: none;
    cursor: pointer;
  }
  .timeline::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--p1);
    cursor: pointer;
    box-shadow: 0 0 6px var(--p1-glow);
  }
  .timeline::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--p1);
    cursor: pointer;
    border: none;
  }
  .btn-row {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .ctrl-btn {
    font-family: var(--mono);
    font-size: 11px;
    font-weight: 600;
    padding: 6px 12px;
    border-radius: 6px;
    border: 1px solid var(--border-b);
    background: var(--surface2);
    color: var(--text);
    cursor: pointer;
    transition: all 0.1s;
    user-select: none;
  }
  .ctrl-btn:hover { background: var(--surface-el); }
  .ctrl-btn:active { transform: scale(0.97); }
  .ctrl-btn.active { background: var(--p1); color: var(--bg); border-color: var(--p1); }
  .ctrl-btn.play { min-width: 50px; }
  .speed-label {
    font-family: var(--mono);
    font-size: 10px;
    color: var(--dim);
    margin-left: auto;
    user-select: none;
  }

  /* -- Data source selector -- */
  .data-source {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .data-source label {
    font-family: var(--mono);
    font-size: 10px;
    color: var(--dim);
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  .data-source select {
    font-family: var(--mono);
    font-size: 11px;
    padding: 4px 8px;
    border-radius: 4px;
    border: 1px solid var(--border-b);
    background: var(--surface2);
    color: var(--text);
    cursor: pointer;
  }
  .data-source .file-btn {
    font-family: var(--mono);
    font-size: 11px;
    font-weight: 600;
    padding: 4px 8px;
    border-radius: 4px;
    border: 1px solid var(--border-b);
    background: var(--surface2);
    color: var(--text);
    cursor: pointer;
  }
  .data-source .file-btn:hover { background: var(--surface-el); }

  .canvas-area.drag-over::after {
    content: 'Drop JSON file to load';
    position: absolute;
    inset: 12px;
    border: 1px dashed rgba(245,158,11,0.5);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: rgba(245,158,11,0.9);
    font-family: var(--mono);
    font-size: 12px;
    letter-spacing: 0.5px;
    background: rgba(245,158,11,0.04);
    pointer-events: none;
  }

  /* -- Keyboard hint -- */
  .kb-hint {
    font-family: var(--mono);
    font-size: 9px;
    color: var(--dim);
    text-align: center;
    padding: 4px;
    opacity: 0.6;
  }
  kbd {
    display: inline-block;
    padding: 1px 5px;
    border-radius: 3px;
    border: 1px solid var(--border-b);
    background: var(--surface2);
    font-family: var(--mono);
    font-size: 9px;
  }
  /* -- Render mode loading pulse -- */
  .ctrl-btn.loading {
    animation: pulse 1s ease-in-out infinite;
    pointer-events: none;
    opacity: 0.7;
  }
  @keyframes pulse {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 0.4; }
  }
</style>
<!-- fflate: MIT-licensed ZIP decompression (~13KB gzipped) -->
<script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>
</head>
<body>

<div class="header">
  <h1>World Model <span>State Visualizer</span></h1>
  <span class="tag" id="dataTag">Mock Data</span>
  <div class="data-source">
    <label>Source:</label>
    <select id="dataSource">
      <option value="neutral">Neutral game</option>
      <option value="combo">Combo sequence</option>
      <option value="edgeguard">Edgeguard</option>
    </select>
    <button class="file-btn" id="btnLoadFile" type="button">Load JSON</button>
    <input id="fileInput" type="file" accept=".json,application/json" hidden>
  </div>
  <div class="frame-counter">Frame <b id="frameNum">0</b> / <b id="totalFrames">0</b></div>
</div>

<div class="main">
  <div class="canvas-area" id="canvasArea">
    <canvas id="stage"></canvas>
  </div>
  <div class="panel">
    <div class="panel-section">
      <div class="panel-label">Player 1</div>
      <div class="player-card p1">
        <div class="pc-header">
          <span class="pc-name" style="color:var(--p1)" id="p1Name">P1</span>
          <span class="pc-char" id="p1Char">Marth</span>
        </div>
        <div class="pc-percent" id="p1Pct">0%</div>
        <div class="stocks-row" id="p1Stocks"></div>
        <div class="pc-action" id="p1Action">Wait (14)</div>
        <div style="margin-top:8px">
          <div class="pc-row"><span class="label">Position</span><span class="value" id="p1Pos">0, 0</span></div>
          <div class="pc-row"><span class="label">Velocity</span><span class="value" id="p1Vel">0, 0</span></div>
          <div class="pc-row"><span class="label">Facing</span><span class="value" id="p1Face">Right</span></div>
          <div class="pc-row"><span class="label">Airborne</span><span class="value" id="p1Air">No</span></div>
          <div class="pc-row"><span class="label">Shield</span><span class="value" id="p1Shield">60.0</span></div>
          <div class="pc-row"><span class="label">Jumps</span><span class="value" id="p1Jumps">2</span></div>
          <div class="pc-row"><span class="label">State age</span><span class="value" id="p1StateAge">0</span></div>
          <div class="pc-row"><span class="label">Hitlag</span><span class="value" id="p1Hitlag">0</span></div>
        </div>
      </div>
    </div>
    <div class="panel-section">
      <div class="panel-label">Player 2</div>
      <div class="player-card p2">
        <div class="pc-header">
          <span class="pc-name" style="color:var(--p2)" id="p2Name">P2</span>
          <span class="pc-char" id="p2Char">Fox</span>
        </div>
        <div class="pc-percent" id="p2Pct">0%</div>
        <div class="stocks-row" id="p2Stocks"></div>
        <div class="pc-action" id="p2Action">Wait (14)</div>
        <div style="margin-top:8px">
          <div class="pc-row"><span class="label">Position</span><span class="value" id="p2Pos">0, 0</span></div>
          <div class="pc-row"><span class="label">Velocity</span><span class="value" id="p2Vel">0, 0</span></div>
          <div class="pc-row"><span class="label">Facing</span><span class="value" id="p2Face">Left</span></div>
          <div class="pc-row"><span class="label">Airborne</span><span class="value" id="p2Air">No</span></div>
          <div class="pc-row"><span class="label">Shield</span><span class="value" id="p2Shield">60.0</span></div>
          <div class="pc-row"><span class="label">Jumps</span><span class="value" id="p2Jumps">2</span></div>
          <div class="pc-row"><span class="label">State age</span><span class="value" id="p2StateAge">0</span></div>
          <div class="pc-row"><span class="label">Hitlag</span><span class="value" id="p2Hitlag">0</span></div>
        </div>
      </div>
    </div>
    <div class="panel-section" style="flex:1">
      <div class="panel-label">Raw Frame Data</div>
      <div class="inspector" id="inspector"></div>
    </div>
  </div>
</div>

<div class="controls">
  <div class="timeline-row">
    <input type="range" class="timeline" id="timeline" min="0" max="0" value="0">
  </div>
  <div class="btn-row">
    <button class="ctrl-btn" id="btnPrevFrame" title="Previous frame">&larr;</button>
    <button class="ctrl-btn play" id="btnPlay" title="Play/Pause">&#9654;</button>
    <button class="ctrl-btn" id="btnNextFrame" title="Next frame">&rarr;</button>
    <button class="ctrl-btn" id="btnSpeed">1x</button>
    <span class="speed-label" id="speedLabel">60 fps</span>
    <button class="ctrl-btn" id="btnRenderMode">Capsule</button>
    <span class="kb-hint" style="margin-left:auto">
      <kbd>Space</kbd> play &nbsp; <kbd>&larr;</kbd><kbd>&rarr;</kbd> step &nbsp; <kbd>+</kbd><kbd>-</kbd> speed &nbsp; <kbd>C</kbd> render
    </span>
  </div>
</div>

<script>
// =====================================================================
// ACTION STATE NAMES (subset -- the important ones for display)
// =====================================================================
const ACTION_NAMES = {
  0: 'DeadDown', 1: 'DeadLeft', 2: 'DeadRight', 3: 'DeadUp',
  14: 'Wait', 15: 'WalkSlow', 16: 'WalkMiddle', 17: 'WalkFast',
  20: 'Dash', 21: 'Run', 22: 'RunDirect', 23: 'RunBrake',
  24: 'KneeBend', 25: 'JumpF', 26: 'JumpB', 27: 'JumpAerialF',
  28: 'JumpAerialB', 29: 'Fall', 30: 'FallF', 31: 'FallB',
  32: 'FallAerial', 33: 'FallAerialF', 34: 'FallAerialB',
  35: 'FallSpecial', 36: 'FallSpecialF', 37: 'FallSpecialB',
  39: 'SquatWait', 40: 'Squat', 41: 'SquatRv',
  42: 'AttackS3Hi', 43: 'AttackS3HiS', 44: 'AttackS3S',
  45: 'AttackS3LwS', 46: 'AttackS3Lw',
  47: 'AttackHi3', 48: 'AttackLw3',
  49: 'AttackS4Hi', 50: 'AttackS4HiS', 51: 'AttackS4S',
  52: 'AttackS4LwS', 53: 'AttackS4Lw',
  54: 'AttackHi4', 55: 'AttackLw4',
  56: 'AttackAirN', 57: 'AttackAirF', 58: 'AttackAirB',
  59: 'AttackAirHi', 60: 'AttackAirLw',
  61: 'LandingAirN', 62: 'LandingAirF', 63: 'LandingAirB',
  64: 'LandingAirHi', 65: 'LandingAirLw',
  75: 'DamageFlyHi', 76: 'DamageFlyN', 77: 'DamageFlyLw',
  78: 'DamageFlyTop', 79: 'DamageFlyRoll',
  85: 'DamageHi1', 86: 'DamageHi2', 87: 'DamageHi3',
  88: 'DamageN1', 89: 'DamageN2', 90: 'DamageN3',
  91: 'DamageLw1', 92: 'DamageLw2', 93: 'DamageLw3',
  178: 'GuardOn', 179: 'Guard', 180: 'GuardOff',
  181: 'GuardSetOff', 182: 'GuardReflect',
  183: 'EscapeF', 184: 'EscapeB',
  199: 'ReboundStop',
  212: 'Catch', 214: 'CatchWait',
  233: 'Landing', 234: 'LandingFallSpecial',
  253: 'CliffCatch', 254: 'CliffWait',
  255: 'CliffClimbSlow', 256: 'CliffClimbQuick',
  263: 'CliffJumpSlow1', 264: 'CliffJumpQuick1',
};

// Friendly attack names for hit detection labels
const ATTACK_DISPLAY_NAMES = {
  42: 'Ftilt!', 43: 'Ftilt!', 44: 'Ftilt!', 45: 'Ftilt!', 46: 'Ftilt!',
  47: 'Utilt!', 48: 'Dtilt!',
  49: 'Fsmash!', 50: 'Fsmash!', 51: 'Fsmash!', 52: 'Fsmash!', 53: 'Fsmash!',
  54: 'Upsmash!', 55: 'Dsmash!',
  56: 'Nair!', 57: 'Fair!', 58: 'Bair!', 59: 'Uair!', 60: 'Dair!',
  212: 'Grab!',
};

function actionName(id) {
  return ACTION_NAMES[id] || `State_${id}`;
}

function attackDisplayName(id) {
  return ATTACK_DISPLAY_NAMES[id] || actionName(id);
}

// Action state categories for coloring
function actionCategory(id) {
  if (id <= 10) return 'dead';
  if (id === 14) return 'neutral';
  if (id >= 15 && id <= 23) return 'movement';
  if (id >= 24 && id <= 37) return 'aerial';
  if (id >= 39 && id <= 41) return 'movement';
  if (id >= 42 && id <= 65) return 'attack';
  if (id >= 75 && id <= 93) return 'damage';
  if (id >= 178 && id <= 184) return 'defense';
  if (id >= 212 && id <= 214) return 'grab';
  if (id >= 253 && id <= 264) return 'ledge';
  return 'other';
}

const CATEGORY_COLORS = {
  neutral:  'rgba(255,255,255,0.5)',
  movement: 'rgba(6,182,212,0.8)',
  aerial:   'rgba(167,139,250,0.8)',
  attack:   'rgba(244,63,94,0.9)',
  damage:   'rgba(245,158,11,0.9)',
  defense:  'rgba(34,197,94,0.7)',
  grab:     'rgba(236,72,153,0.8)',
  ledge:    'rgba(99,102,241,0.8)',
  dead:     'rgba(107,114,128,0.5)',
  other:    'rgba(148,163,184,0.5)',
};

const CHARACTERS = {
  0: 'Mario', 1: 'Fox', 2: 'Cpt. Falcon', 3: 'DK', 4: 'Kirby',
  5: 'Bowser', 6: 'Link', 7: 'Sheik', 8: 'Ness', 9: 'Peach',
  10: 'Popo', 12: 'Pikachu', 13: 'Samus', 17: 'Luigi',
  18: 'Marth', 19: 'Zelda', 20: 'Young Link', 21: 'Doc',
  22: 'Falco', 23: 'Pichu', 24: 'G&W', 25: 'Ganondorf',
  26: 'Roy', 31: 'Mewtwo', 32: 'Jigglypuff',
};

// =====================================================================
// CHARACTER ANIMATION DATA (ported from nojohns/SlippiLab, MIT)
// =====================================================================

// Internal character ID -> external character ID (for animation ZIP lookup)
const EXTERNAL_ID_BY_INTERNAL_ID = {
  0: 8, 1: 2, 2: 0, 3: 1, 4: 4, 5: 5, 6: 6, 7: 19, 8: 11, 9: 12,
  10: 14, 11: 14, 12: 13, 13: 16, 14: 17, 15: 15, 16: 10, 17: 7,
  18: 9, 19: 18, 20: 21, 21: 22, 22: 20, 23: 24, 24: 3, 25: 25, 26: 23,
};

// Action state ID -> action name (full 341-entry table from SlippiLab)
const ACTION_NAME_BY_ID = [
  "DeadDown", "DeadLeft", "DeadRight", "DeadUp", "DeadUpStar", "DeadUpStarIce",
  "DeadUpFall", "DeadUpFallHitCamera", "DeadUpFallHitCameraFlat", "DeadUpFallIce",
  "DeadUpFallHitCameraIce", "Sleep", "Rebirth", "RebirthWait", "Wait", "WalkSlow",
  "WalkMiddle", "WalkFast", "Turn", "TurnRun", "Dash", "Run", "RunDirect", "RunBrake",
  "KneeBend", "JumpF", "JumpB", "JumpAerialF", "JumpAerialB", "Fall", "FallF", "FallB",
  "FallAerial", "FallAerialF", "FallAerialB", "FallSpecial", "FallSpecialF", "FallSpecialB",
  "DamageFall", "Squat", "SquatWait", "SquatRv", "Landing", "LandingFallSpecial",
  "Attack11", "Attack12", "Attack13", "Attack100Start", "Attack100Loop", "Attack100End",
  "AttackDash", "AttackS3Hi", "AttackS3HiS", "AttackS3S", "AttackS3LwS", "AttackS3Lw",
  "AttackHi3", "AttackLw3", "AttackS4Hi", "AttackS4HiS", "AttackS4S", "AttackS4LwS",
  "AttackS4Lw", "AttackHi4", "AttackLw4", "AttackAirN", "AttackAirF", "AttackAirB",
  "AttackAirHi", "AttackAirLw", "LandingAirN", "LandingAirF", "LandingAirB", "LandingAirHi",
  "LandingAirLw", "DamageHi1", "DamageHi2", "DamageHi3", "DamageN1", "DamageN2", "DamageN3",
  "DamageLw1", "DamageLw2", "DamageLw3", "DamageAir1", "DamageAir2", "DamageAir3",
  "DamageFlyHi", "DamageFlyN", "DamageFlyLw", "DamageFlyTop", "DamageFlyRoll",
  "LightGet", "HeavyGet", "LightThrowF", "LightThrowB", "LightThrowHi", "LightThrowLw",
  "LightThrowDash", "LightThrowDrop", "LightThrowAirF", "LightThrowAirB", "LightThrowAirHi",
  "LightThrowAirLw", "HeavyThrowF", "HeavyThrowB", "HeavyThrowHi", "HeavyThrowLw",
  "LightThrowF4", "LightThrowB4", "LightThrowHi4", "LightThrowLw4", "LightThrowAirF4",
  "LightThrowAirB4", "LightThrowAirHi4", "LightThrowAirLw4", "HeavyThrowF4", "HeavyThrowB4",
  "HeavyThrowHi4", "HeavyThrowLw4", "SwordSwing1", "SwordSwing3", "SwordSwing4",
  "SwordSwingDash", "BatSwing1", "BatSwing3", "BatSwing4", "BatSwingDash", "ParasolSwing1",
  "ParasolSwing3", "ParasolSwing4", "ParasolSwingDash", "HarisenSwing1", "HarisenSwing3",
  "HarisenSwing4", "HarisenSwingDash", "StarRodSwing1", "StarRodSwing3", "StarRodSwing4",
  "StarRodSwingDash", "LipStickSwing1", "LipStickSwing3", "LipStickSwing4", "LipStickSwingDash",
  "ItemParasolOpen", "ItemParasolFall", "ItemParasolFallSpecial", "ItemParasolDamageFall",
  "LGunShoot", "LGunShootAir", "LGunShootEmpty", "LGunShootAirEmpty", "FireFlowerShoot",
  "FireFlowerShootAir", "ItemScrew", "ItemScrewAir", "DamageScrew", "DamageScrewAir",
  "ItemScopeStart", "ItemScopeRapid", "ItemScopeFire", "ItemScopeEnd", "ItemScopeAirStart",
  "ItemScopeAirRapid", "ItemScopeAirFire", "ItemScopeAirEnd", "ItemScopeStartEmpty",
  "ItemScopeRapidEmpty", "ItemScopeFireEmpty", "ItemScopeEndEmpty", "ItemScopeAirStartEmpty",
  "ItemScopeAirRapidEmpty", "ItemScopeAirFireEmpty", "ItemScopeAirEndEmpty", "LiftWait",
  "LiftWalk1", "LiftWalk2", "LiftTurn", "GuardOn", "Guard", "GuardOff", "GuardSetOff",
  "GuardReflect", "DownBoundU", "DownWaitU", "DownDamageU", "DownStandU", "DownAttackU",
  "DownFowardU", "DownBackU", "DownSpotU", "DownBoundD", "DownWaitD", "DownDamageD",
  "DownStandD", "DownAttackD", "DownFowardD", "DownBackD", "DownSpotD", "Passive",
  "PassiveStandF", "PassiveStandB", "PassiveWall", "PassiveWallJump", "PassiveCeil",
  "ShieldBreakFly", "ShieldBreakFall", "ShieldBreakDownU", "ShieldBreakDownD",
  "ShieldBreakStandU", "ShieldBreakStandD", "FuraFura", "Catch", "CatchPull", "CatchDash",
  "CatchDashPull", "CatchWait", "CatchAttack", "CatchCut", "ThrowF", "ThrowB", "ThrowHi",
  "ThrowLw", "CapturePulledHi", "CaptureWaitHi", "CaptureDamageHi", "CapturePulledLw",
  "CaptureWaitLw", "CaptureDamageLw", "CaptureCut", "CaptureJump", "CaptureNeck",
  "CaptureFoot", "EscapeF", "EscapeB", "Escape", "EscapeAir", "ReboundStop", "Rebound",
  "ThrownF", "ThrownB", "ThrownHi", "ThrownLw", "ThrownLwWomen", "Pass", "Ottotto",
  "OttottoWait", "FlyReflectWall", "FlyReflectCeil", "StopWall", "StopCeil", "MissFoot",
  "CliffCatch", "CliffWait", "CliffClimbSlow", "CliffClimbQuick", "CliffAttackSlow",
  "CliffAttackQuick", "CliffEscapeSlow", "CliffEscapeQuick", "CliffJumpSlow1",
  "CliffJumpSlow2", "CliffJumpQuick1", "CliffJumpQuick2", "AppealR", "AppealL",
  "ShoulderedWait", "ShoulderedWalkSlow", "ShoulderedWalkMiddle", "ShoulderedWalkFast",
  "ShoulderedTurn", "ThrownFF", "ThrownFB", "ThrownFHi", "ThrownFLw", "CaptureCaptain",
  "CaptureYoshi", "YoshiEgg", "CaptureKoopa", "CaptureDamageKoopa", "CaptureWaitKoopa",
  "ThrownKoopaF", "ThrownKoopaB", "CaptureKoopaAir", "CaptureDamageKoopaAir",
  "CaptureWaitKoopaAir", "ThrownKoopaAirF", "ThrownKoopaAirB", "CaptureKirby",
  "CaptureWaitKirby", "ThrownKirbyStar", "ThrownCopyStar", "ThrownKirby", "BarrelWait",
  "Bury", "BuryWait", "BuryJump", "DamageSong", "DamageSongWait", "DamageSongRv",
  "DamageBind", "CaptureMewtwo", "CaptureMewtwoAir", "ThrownMewtwo", "ThrownMewtwoAir",
  "WarpStarJump", "WarpStarFall", "HammerWait", "HammerWalk", "HammerTurn", "HammerKneeBend",
  "HammerFall", "HammerJump", "HammerLanding", "KinokoGiantStart", "KinokoGiantStartAir",
  "KinokoGiantEnd", "KinokoGiantEndAir", "KinokoSmallStart", "KinokoSmallStartAir",
  "KinokoSmallEnd", "KinokoSmallEndAir", "Entry", "EntryStart", "EntryEnd", "DamageIce",
  "DamageIceJump", "CaptureMasterhand", "CapturedamageMasterhand", "CapturewaitMasterhand",
  "ThrownMasterhand", "CaptureCrazyhand", "CapturedamageCrazyhand", "CapturewaitCrazyhand",
  "ThrownCrazyhand", "CaptureKirbyYoshi", "KirbyYoshiEgg", "CaptureLeadead",
  "CaptureLikelike", "DownReflect", "CaptureCrazyhandAir", "CapturedamageCrazyhandAir",
  "CapturewaitCrazyhandAir", "ThrownCrazyhandAir", "CaptureMasterhandAir",
  "CapturedamageMasterhandAir", "CapturewaitMasterhandAir", "ThrownMasterhandAir",
];

// Animation name remaps (common across characters)
const ANIMATION_REMAPS = {
  "AppealL": "Appeal",
  "AppealR": "Appeal",
  "Escape": "EscapeN",
  "GuardReflect": "Guard",
  "GuardSetOff": "GuardDamage",
  "KneeBend": "Landing",
  "LandingFallSpecial": "Landing",
  "CatchDashPull": "CatchWait",
  "CatchPull": "CatchWait",
  "EntryEnd": "Entry",
  "EntryStart": "Entry",
  "Wait": "Wait1",
};

// Per-character scale factors (indexed by external ID)
const CHAR_SCALE = {
  0: 1.12, 1: 1.30, 2: 0.96, 3: 0.85, 4: 0.82, 5: 0.90,
  6: 1.05, 7: 0.95, 8: 0.95, 9: 1.05, 10: 1.30, 11: 0.90,
  12: 0.95, 13: 0.85, 14: 0.90, 15: 0.70, 16: 1.10, 17: 1.00,
  18: 1.00, 19: 0.96, 20: 0.98, 21: 1.05, 22: 0.95, 23: 1.05,
  24: 0.55, 25: 1.20,
};

// External character ID -> ZIP filename (without .zip extension)
const CHAR_ZIP = {
  0: "captainFalcon", 1: "donkeyKong", 2: "fox", 3: "mrGameAndWatch", 4: "kirby",
  5: "bowser", 6: "link", 7: "luigi", 8: "mario", 9: "marth", 10: "mewtwo",
  11: "ness", 12: "peach", 13: "pikachu", 14: "iceClimbers", 15: "jigglypuff",
  16: "samus", 17: "yoshi", 18: "zelda", 19: "sheik", 20: "falco",
  21: "youngLink", 22: "doctorMario", 23: "roy", 24: "pichu", 25: "ganondorf",
};

// =====================================================================
// ANIMATION CACHE
// =====================================================================

const animCache = new Map();
const animLoading = new Map();
const path2dCache = new Map();
let fflateAvailable = typeof window.fflate !== 'undefined';

async function loadCharAnimations(internalCharId) {
  const extId = EXTERNAL_ID_BY_INTERNAL_ID[internalCharId];
  if (extId === undefined) return null;
  if (animCache.has(extId)) return animCache.get(extId);
  if (animLoading.has(extId)) return animLoading.get(extId);

  const zipName = CHAR_ZIP[extId];
  if (!zipName) return null;

  const promise = (async () => {
    try {
      const resp = await fetch(`zips/${zipName}.zip`);
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const buf = await resp.arrayBuffer();
      const unzipped = fflate.unzipSync(new Uint8Array(buf));
      const animations = {};
      for (const [filename, data] of Object.entries(unzipped)) {
        if (!filename.endsWith('.json')) continue;
        const animName = filename.replace('.json', '');
        animations[animName] = JSON.parse(new TextDecoder().decode(data));
      }
      animCache.set(extId, animations);
      console.log(`[anim] Loaded ${zipName}: ${Object.keys(animations).length} animations`);
      return animations;
    } catch (err) {
      console.error(`[anim] Failed to load ${zipName}.zip:`, err);
      return null;
    } finally {
      animLoading.delete(extId);
    }
  })();

  animLoading.set(extId, promise);
  return promise;
}

function resolveAnimFrame(animations, actionStateId, stateAge) {
  if (!animations) return null;
  const rawName = ACTION_NAME_BY_ID[actionStateId];
  if (!rawName) return null;
  const animName = ANIMATION_REMAPS[rawName] || rawName;
  const frames = animations[animName] || animations['Wait1'];
  if (!frames || frames.length === 0) return null;

  const frameIdx = Math.floor(Math.max(0, stateAge)) % frames.length;
  let pathStr = frames[frameIdx];

  if (pathStr && pathStr.startsWith('frame')) {
    const refIdx = parseInt(pathStr.slice(5), 10);
    if (refIdx >= 0 && refIdx < frames.length) pathStr = frames[refIdx];
  }

  return { pathStr, animName, frameIdx };
}

function getPath2D(extId, animName, frameIdx, pathStr) {
  const key = `${extId}:${animName}:${frameIdx}`;
  let cached = path2dCache.get(key);
  if (cached) return cached;
  try {
    cached = new Path2D(pathStr);
    path2dCache.set(key, cached);
    return cached;
  } catch (_) {
    return null;
  }
}

// Returns true if character was drawn, false if fallback to capsule is needed
function drawCharacter(ctx, p, px, py, pxPerUnit, col) {
  const extId = EXTERNAL_ID_BY_INTERNAL_ID[p.character];
  if (extId === undefined) return false;
  const animations = animCache.get(extId);
  if (!animations) return false;

  const resolved = resolveAnimFrame(animations, p.action_state, p.state_age);
  if (!resolved || !resolved.pathStr) return false;

  const path2d = getPath2D(extId, resolved.animName, resolved.frameIdx, resolved.pathStr);
  if (!path2d) return false;

  const charScale = CHAR_SCALE[extId] || 1.0;
  const facingDir = p.facing ? 1 : -1;

  ctx.save();
  ctx.translate(px, py);
  ctx.scale(pxPerUnit, pxPerUnit);
  ctx.scale(charScale, charScale);
  ctx.scale(facingDir, 1);
  ctx.scale(0.1, 0.1);
  ctx.translate(-500, -500);

  ctx.fillStyle = col.main;
  ctx.globalAlpha = 0.9;
  ctx.fill(path2d);

  ctx.strokeStyle = 'rgba(0,0,0,0.5)';
  ctx.lineWidth = 5;
  ctx.stroke(path2d);

  ctx.globalAlpha = 1;
  ctx.restore();
  return true;
}

let renderMode = 'capsule'; // 'capsule' | 'character'

// =====================================================================
// STAGE GEOMETRY (Final Destination)
// =====================================================================
const STAGE = {
  name: 'Final Destination',
  ground: { x1: -85.5606, x2: 85.5606, y: 0 },
  blastzone: { left: -246, right: 246, top: 188, bottom: -140 },
  camera: { left: -170, right: 170, top: 120, bottom: -60 },
};

// Player capsule dimensions in game units (Melee character ~10 units tall, ~3.5 wide)
const CAPSULE_GAME_H = 10;
const CAPSULE_GAME_W = 3.5;


// =====================================================================
// MOCK DATA GENERATOR
// =====================================================================

function generateMockData(scenario) {
  const gen = {
    neutral: generateNeutral,
    combo: generateCombo,
    edgeguard: generateEdgeguard,
  };
  return (gen[scenario] || gen.neutral)();
}

function makePlayer(x, y, char, facing) {
  return {
    x, y, percent: 0, shield_strength: 60,
    speed_air_x: 0, speed_y: 0, speed_ground_x: 0,
    speed_attack_x: 0, speed_attack_y: 0,
    state_age: 0, hitlag: 0, stocks: 4,
    facing, on_ground: y <= 1 ? 1 : 0,
    action_state: 14, jumps_left: 2, character: char,
  };
}

function clonePlayer(p) { return { ...p }; }

function applyGravity(p) {
  if (!p.on_ground) {
    p.speed_y -= 0.13;
    if (p.speed_y < -3.5) p.speed_y = -3.5;
  }
}

function applyMovement(p) {
  if (p.on_ground) {
    p.x += p.speed_ground_x;
    p.speed_ground_x *= 0.9;
  } else {
    p.x += p.speed_air_x;
    p.y += p.speed_y;
  }
  p.x += p.speed_attack_x;
  p.y += p.speed_attack_y;
  p.speed_attack_x *= 0.95;
  p.speed_attack_y *= 0.95;
  if (Math.abs(p.speed_attack_x) < 0.05) p.speed_attack_x = 0;
  if (Math.abs(p.speed_attack_y) < 0.05) p.speed_attack_y = 0;
}

function applyStageCollision(p) {
  if (p.y <= STAGE.ground.y && p.x >= STAGE.ground.x1 && p.x <= STAGE.ground.x2) {
    if (!p.on_ground) {
      p.y = STAGE.ground.y;
      p.on_ground = 1;
      p.speed_y = 0;
      p.speed_air_x = 0;
      p.jumps_left = p.character === 4 ? 6 : 2;
    }
  }
  if (p.on_ground && (p.x < STAGE.ground.x1 || p.x > STAGE.ground.x2)) {
    p.on_ground = 0;
  }
}

function generateNeutral() {
  const frames = [];
  const p0 = makePlayer(-30, 0, 18, 1);
  const p1 = makePlayer(30, 0, 1, 0);
  const N = 360;

  for (let i = 0; i < N; i++) {
    const f0 = clonePlayer(p0);
    const f1 = clonePlayer(p1);
    const phase = Math.floor(i / 60);
    const t = (i % 60) / 60;

    if (phase === 0) {
      f0.action_state = 14;
      f1.action_state = 14;
      p0.speed_ground_x = Math.sin(i * 0.05) * 0.3;
      p1.speed_ground_x = -Math.sin(i * 0.07) * 0.2;
    }
    else if (phase === 1) {
      if (t < 0.3) {
        f0.action_state = 20;
        p0.speed_ground_x = 2.0;
      } else if (t < 0.5) {
        f0.action_state = 44;
        p0.speed_ground_x *= 0.3;
        if (t > 0.4 && t < 0.5 && Math.abs(p0.x - p1.x) < 20) {
          f1.action_state = 88;
          p1.speed_attack_x = 2.5;
          p1.speed_attack_y = 1.5;
          p1.on_ground = 0;
          p1.percent += 12;
          f0.hitlag = 4; f1.hitlag = 4;
        }
      } else {
        f0.action_state = 14;
        p0.speed_ground_x *= 0.8;
      }
      if (f1.action_state >= 75 && f1.action_state <= 93) {
        f1.state_age = Math.floor((t - 0.4) * 60);
      } else if (!p1.on_ground && p1.y > 0) {
        f1.action_state = 29;
      } else {
        f1.action_state = 14;
      }
    }
    else if (phase === 2) {
      if (t < 0.15) {
        f1.action_state = 24;
        f1.facing = 0;
      } else if (t < 0.2) {
        f1.action_state = 25;
        p1.speed_y = 3.2;
        p1.speed_air_x = -1.5;
        p1.on_ground = 0;
        p1.jumps_left = 1;
      } else if (t < 0.45) {
        f1.action_state = 57;
        f1.on_ground = 0;
      } else if (t < 0.6) {
        f1.action_state = 29;
        f1.on_ground = 0;
      } else {
        f1.action_state = 233;
        if (t > 0.7) f1.action_state = 14;
      }
      if (t > 0.3 && t < 0.6) {
        f0.action_state = 179;
        p0.shield_strength = Math.max(30, p0.shield_strength - 0.3);
      } else {
        f0.action_state = 14;
      }
    }
    else if (phase === 3) {
      const dd0 = Math.sin(i * 0.15) > 0;
      const dd1 = Math.sin(i * 0.12 + 1) > 0;
      f0.action_state = 20;
      f1.action_state = 20;
      f0.facing = dd0 ? 1 : 0;
      f1.facing = dd1 ? 1 : 0;
      p0.speed_ground_x = dd0 ? 1.8 : -1.8;
      p1.speed_ground_x = dd1 ? 1.6 : -1.6;
    }
    else if (phase === 4) {
      if (t < 0.2) {
        f0.action_state = 20;
        p0.speed_ground_x = 2.0;
      } else if (t < 0.35) {
        f0.action_state = 212;
        p0.speed_ground_x = 0;
      } else if (t < 0.7) {
        f0.action_state = 214;
        f1.action_state = 224;
        p0.speed_ground_x = 0;
        p1.x = p0.x + (f0.facing ? 8 : -8);
      } else {
        f0.action_state = 14;
        f1.action_state = 76;
        p1.speed_attack_x = f0.facing ? 3 : -3;
        p1.speed_attack_y = 2;
        p1.on_ground = 0;
        p1.percent += 8;
        f0.hitlag = 3; f1.hitlag = 3;
      }
    }
    else {
      f0.action_state = 14;
      f1.action_state = 14;
      p0.speed_ground_x += (-30 - p0.x) * 0.02;
      p1.speed_ground_x += (30 - p1.x) * 0.02;
    }

    f0.state_age = (frames.length > 0 && frames[frames.length-1].players[0].action_state === f0.action_state)
      ? frames[frames.length-1].players[0].state_age + 1 : 0;
    f1.state_age = (frames.length > 0 && frames[frames.length-1].players[1].action_state === f1.action_state)
      ? frames[frames.length-1].players[1].state_age + 1 : 0;

    applyGravity(p0); applyGravity(p1);
    applyMovement(p0); applyMovement(p1);
    applyStageCollision(p0); applyStageCollision(p1);

    f0.x = p0.x; f0.y = p0.y;
    f0.speed_air_x = p0.speed_air_x; f0.speed_y = p0.speed_y;
    f0.speed_ground_x = p0.speed_ground_x;
    f0.speed_attack_x = p0.speed_attack_x; f0.speed_attack_y = p0.speed_attack_y;
    f0.on_ground = p0.on_ground; f0.percent = p0.percent;
    f0.shield_strength = p0.shield_strength;
    f0.jumps_left = p0.jumps_left;

    f1.x = p1.x; f1.y = p1.y;
    f1.speed_air_x = p1.speed_air_x; f1.speed_y = p1.speed_y;
    f1.speed_ground_x = p1.speed_ground_x;
    f1.speed_attack_x = p1.speed_attack_x; f1.speed_attack_y = p1.speed_attack_y;
    f1.on_ground = p1.on_ground; f1.percent = p1.percent;
    f1.shield_strength = p1.shield_strength;
    f1.jumps_left = p1.jumps_left;

    frames.push({ players: [f0, f1], stage: 31 });
  }
  return frames;
}

function generateCombo() {
  const frames = [];
  const p0 = makePlayer(-20, 0, 2, 1);
  const p1 = makePlayer(20, 0, 22, 0);
  const N = 300;

  const script = [
    { dur: 30, p0a: 20, p1a: 14, p0vx: 2.2, setup: (i, f0, f1, pp0, pp1) => {
      if (i > 20) { f0.action_state = 212; pp0.speed_ground_x = 0; }
    }},
    { dur: 30, p0a: 214, p1a: 224, setup: (i, f0, f1, pp0, pp1) => {
      pp1.x = pp0.x + 8;
    }},
    { dur: 15, p0a: 14, p1a: 78, setup: (i, f0, f1, pp0, pp1) => {
      if (i === 0) {
        pp1.speed_attack_y = 4; pp1.speed_attack_x = 0.3;
        pp1.on_ground = 0; pp1.percent += 7;
        f0.hitlag = 3; f1.hitlag = 3;
      }
    }},
    { dur: 20, p0a: 24, setup: (i, f0, f1, pp0, pp1) => {
      if (i === 5) { pp0.speed_y = 4.5; pp0.speed_air_x = 1.2; pp0.on_ground = 0; pp0.jumps_left = 1; f0.action_state = 27; }
      if (i > 5) f0.action_state = 27;
      f1.action_state = pp1.speed_attack_y > 0.3 ? 78 : 29;
    }},
    { dur: 20, p0a: 56, setup: (i, f0, f1, pp0, pp1) => {
      f0.on_ground = 0;
      if (i === 8 && Math.abs(pp0.y - pp1.y) < 25) {
        f1.action_state = 76; pp1.speed_attack_x = 1.5; pp1.speed_attack_y = 2;
        pp1.percent += 14; f0.hitlag = 4; f1.hitlag = 4;
      } else {
        f1.action_state = pp1.speed_attack_y > 0.3 ? 76 : 29;
      }
    }},
    { dur: 25, p0a: 29, setup: (i, f0, f1, pp0, pp1) => {
      f0.on_ground = 0;
      f1.action_state = pp1.speed_attack_y > 0.3 ? 76 : 29;
      f1.on_ground = 0;
      if (i === 10 && pp0.jumps_left > 0) {
        pp0.speed_y = 3.8; pp0.jumps_left = 0; f0.action_state = 28;
      }
    }},
    { dur: 20, p0a: 59, setup: (i, f0, f1, pp0, pp1) => {
      f0.on_ground = 0;
      if (i === 6) {
        f1.action_state = 75; pp1.speed_attack_y = 3.5; pp1.speed_attack_x = 0.5;
        pp1.percent += 13; f0.hitlag = 5; f1.hitlag = 5;
      } else {
        f1.action_state = pp1.speed_attack_y > 0.3 ? 75 : 29;
      }
      f1.on_ground = 0;
    }},
    { dur: 60, p0a: 29, setup: (i, f0, f1, pp0, pp1) => {
      f1.action_state = pp1.speed_attack_y > 0.3 ? 75 : 29;
      f0.on_ground = pp0.on_ground; f1.on_ground = pp1.on_ground;
      if (pp0.on_ground) f0.action_state = 233;
      if (pp1.on_ground) f1.action_state = 233;
      if (pp0.on_ground && i > 10) f0.action_state = 14;
      if (pp1.on_ground && i > 15) f1.action_state = 14;
    }},
  ];

  let phaseIdx = 0;
  let phaseFrame = 0;

  for (let i = 0; i < N; i++) {
    const f0 = clonePlayer(p0);
    const f1 = clonePlayer(p1);

    if (phaseIdx < script.length) {
      const phase = script[phaseIdx];
      f0.action_state = phase.p0a || f0.action_state;
      if (phase.p1a !== undefined) f1.action_state = phase.p1a;
      if (phase.p0vx !== undefined && phaseFrame === 0) p0.speed_ground_x = phase.p0vx;
      if (phase.setup) phase.setup(phaseFrame, f0, f1, p0, p1);
      phaseFrame++;
      if (phaseFrame >= phase.dur) { phaseIdx++; phaseFrame = 0; }
    } else {
      f0.action_state = p0.on_ground ? 14 : 29;
      f1.action_state = p1.on_ground ? 14 : 29;
      p0.speed_ground_x += (-20 - p0.x) * 0.02;
      p1.speed_ground_x += (20 - p1.x) * 0.02;
    }

    f0.state_age = (frames.length > 0 && frames[frames.length-1].players[0].action_state === f0.action_state)
      ? frames[frames.length-1].players[0].state_age + 1 : 0;
    f1.state_age = (frames.length > 0 && frames[frames.length-1].players[1].action_state === f1.action_state)
      ? frames[frames.length-1].players[1].state_age + 1 : 0;

    applyGravity(p0); applyGravity(p1);
    applyMovement(p0); applyMovement(p1);
    applyStageCollision(p0); applyStageCollision(p1);

    f0.x = p0.x; f0.y = p0.y; f0.on_ground = p0.on_ground;
    f0.speed_air_x = p0.speed_air_x; f0.speed_y = p0.speed_y;
    f0.speed_ground_x = p0.speed_ground_x;
    f0.speed_attack_x = p0.speed_attack_x; f0.speed_attack_y = p0.speed_attack_y;
    f0.percent = p0.percent; f0.shield_strength = p0.shield_strength;
    f0.jumps_left = p0.jumps_left; f0.hitlag = Math.max(0, (f0.hitlag || 0) - 1);

    f1.x = p1.x; f1.y = p1.y; f1.on_ground = p1.on_ground;
    f1.speed_air_x = p1.speed_air_x; f1.speed_y = p1.speed_y;
    f1.speed_ground_x = p1.speed_ground_x;
    f1.speed_attack_x = p1.speed_attack_x; f1.speed_attack_y = p1.speed_attack_y;
    f1.percent = p1.percent; f1.shield_strength = p1.shield_strength;
    f1.jumps_left = p1.jumps_left; f1.hitlag = Math.max(0, (f1.hitlag || 0) - 1);

    frames.push({ players: [f0, f1], stage: 31 });
  }
  return frames;
}

function generateEdgeguard() {
  const frames = [];
  const p0 = makePlayer(40, 0, 18, 0);
  const p1 = makePlayer(-120, -30, 1, 1);
  p1.on_ground = 0;
  p1.percent = 80;
  p1.jumps_left = 0;
  p1.speed_air_x = 2.5;
  p1.speed_y = 1.5;
  const N = 300;

  for (let i = 0; i < N; i++) {
    const f0 = clonePlayer(p0);
    const f1 = clonePlayer(p1);
    const t = i / 60;

    if (t < 1.5) {
      f1.action_state = 35;
      if (t < 0.5) {
        p1.speed_air_x = 2.8;
        p1.speed_y = 2.0;
      } else if (t < 1.0) {
        p1.speed_air_x = 1.5;
        p1.speed_y = 0.5;
      }
      f0.action_state = 14;
      if (t > 0.8 && t < 1.2) {
        f0.action_state = 20;
        p0.speed_ground_x = -1.5;
      }
      if (t > 1.2) {
        f0.action_state = 57;
        if (t > 1.0) { p0.on_ground = 0; p0.speed_y = 1; p0.speed_air_x = -1; }
        if (t > 1.3 && t < 1.4 && Math.abs(p0.x - p1.x) < 25) {
          f1.action_state = 77;
          p1.speed_attack_x = -3;
          p1.speed_attack_y = -2;
          p1.percent += 14;
          f0.hitlag = 6; f1.hitlag = 6;
        }
      }
    } else if (t < 3.0) {
      if (p1.speed_attack_y < -0.2 || p1.speed_attack_x < -0.2) {
        f1.action_state = 79;
      } else {
        f1.action_state = 29;
      }
      f1.on_ground = 0;
      f0.action_state = p0.on_ground ? 14 : 29;
      if (!p0.on_ground) {
        p0.speed_air_x += (40 - p0.x) * 0.01;
      } else {
        p0.speed_ground_x += (40 - p0.x) * 0.03;
        f0.action_state = 14;
      }
    } else {
      if (p1.y < STAGE.blastzone.bottom || p1.x < STAGE.blastzone.left) {
        p1.stocks = Math.max(0, p1.stocks - 1);
        p1.x = 0; p1.y = 50; p1.on_ground = 0;
        p1.speed_air_x = 0; p1.speed_y = 0;
        p1.speed_attack_x = 0; p1.speed_attack_y = 0;
        p1.percent = 0;
        p1.jumps_left = 2;
        f1.action_state = 29;
      }
      f0.action_state = p0.on_ground ? 14 : 29;
      f1.action_state = p1.on_ground ? 14 : 29;
      p0.speed_ground_x += (40 - p0.x) * 0.02;
      p1.speed_ground_x += (-20 - p1.x) * 0.01;
    }

    f0.state_age = (frames.length > 0 && frames[frames.length-1].players[0].action_state === f0.action_state)
      ? frames[frames.length-1].players[0].state_age + 1 : 0;
    f1.state_age = (frames.length > 0 && frames[frames.length-1].players[1].action_state === f1.action_state)
      ? frames[frames.length-1].players[1].state_age + 1 : 0;

    applyGravity(p0); applyGravity(p1);
    applyMovement(p0); applyMovement(p1);
    applyStageCollision(p0); applyStageCollision(p1);

    f0.x = p0.x; f0.y = p0.y; f0.on_ground = p0.on_ground;
    f0.speed_air_x = p0.speed_air_x; f0.speed_y = p0.speed_y;
    f0.speed_ground_x = p0.speed_ground_x;
    f0.speed_attack_x = p0.speed_attack_x; f0.speed_attack_y = p0.speed_attack_y;
    f0.percent = p0.percent; f0.shield_strength = p0.shield_strength;
    f0.jumps_left = p0.jumps_left; f0.hitlag = Math.max(0, (f0.hitlag || 0) - 1);
    f0.stocks = p0.stocks;

    f1.x = p1.x; f1.y = p1.y; f1.on_ground = p1.on_ground;
    f1.speed_air_x = p1.speed_air_x; f1.speed_y = p1.speed_y;
    f1.speed_ground_x = p1.speed_ground_x;
    f1.speed_attack_x = p1.speed_attack_x; f1.speed_attack_y = p1.speed_attack_y;
    f1.percent = p1.percent; f1.shield_strength = p1.shield_strength;
    f1.jumps_left = p1.jumps_left; f1.hitlag = Math.max(0, (f1.hitlag || 0) - 1);
    f1.stocks = p1.stocks;

    frames.push({ players: [f0, f1], stage: 31 });
  }
  return frames;
}


// =====================================================================
// PARTICLE SYSTEM (Object-pooled)
// =====================================================================

const PARTICLE_POOL_SIZE = 600;
const particlePool = new Array(PARTICLE_POOL_SIZE);
let particleCount = 0;

for (let i = 0; i < PARTICLE_POOL_SIZE; i++) {
  particlePool[i] = { x:0, y:0, vx:0, vy:0, life:0, maxLife:1, size:2, r:255, g:255, b:255, alpha:1, active:false, gravity:0 };
}

function emitParticle(x, y, vx, vy, life, size, r, g, b, alpha, gravity) {
  // Find a dead particle in the pool
  for (let i = 0; i < PARTICLE_POOL_SIZE; i++) {
    if (!particlePool[i].active) {
      const p = particlePool[i];
      p.x = x; p.y = y; p.vx = vx; p.vy = vy;
      p.life = life; p.maxLife = life;
      p.size = size; p.r = r; p.g = g; p.b = b;
      p.alpha = alpha; p.active = true;
      p.gravity = gravity || 0;
      return p;
    }
  }
  return null; // Pool exhausted
}

function updateParticles() {
  for (let i = 0; i < PARTICLE_POOL_SIZE; i++) {
    const p = particlePool[i];
    if (!p.active) continue;
    p.life--;
    if (p.life <= 0) { p.active = false; continue; }
    p.x += p.vx;
    p.y += p.vy;
    p.vy += p.gravity;
    p.vx *= 0.98;
    p.vy *= 0.98;
  }
}

function drawParticles(ctx) {
  for (let i = 0; i < PARTICLE_POOL_SIZE; i++) {
    const p = particlePool[i];
    if (!p.active) continue;
    const t = p.life / p.maxLife;
    const a = p.alpha * t;
    if (a < 0.01) continue;
    ctx.globalAlpha = a;
    ctx.fillStyle = `rgb(${p.r},${p.g},${p.b})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * t, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function clearAllParticles() {
  for (let i = 0; i < PARTICLE_POOL_SIZE; i++) {
    particlePool[i].active = false;
  }
}


// =====================================================================
// AMBIENT BACKGROUND PARTICLES
// =====================================================================

const AMBIENT_COUNT = 30;
const ambientParticles = [];
for (let i = 0; i < AMBIENT_COUNT; i++) {
  ambientParticles.push({
    x: Math.random(), y: Math.random(),
    vx: (Math.random() - 0.5) * 0.0003,
    vy: (Math.random() - 0.5) * 0.0003,
    alpha: 0.08 + Math.random() * 0.12,
    size: 1 + Math.random() * 1.5,
  });
}

function updateAmbientParticles() {
  for (const p of ambientParticles) {
    p.x += p.vx;
    p.y += p.vy;
    if (p.x < 0) p.x += 1;
    if (p.x > 1) p.x -= 1;
    if (p.y < 0) p.y += 1;
    if (p.y > 1) p.y -= 1;
  }
}

function drawAmbientParticles(ctx, w, h) {
  for (const p of ambientParticles) {
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(p.x * w, p.y * h, p.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}


// =====================================================================
// JUICE STATE
// =====================================================================

// Momentum trails: store last N positions per player
const TRAIL_LENGTH = 12;
const playerTrails = [[], []];

// Screen shake
let shakeX = 0, shakeY = 0;
let shakeMagnitude = 0;

// Hit freeze
let hitFreezeFrames = 0;

// Impact flash effects
const impactFlashes = []; // { x, y, life, maxLife }

// Squash/stretch state per player
const squashState = [
  { scaleX: 1, scaleY: 1, timer: 0, landing: false },
  { scaleX: 1, scaleY: 1, timer: 0, landing: false },
];

// Dynamic camera
let camCenterX = 0, camCenterY = 30;
let camZoom = 1;
let camTargetCenterX = 0, camTargetCenterY = 30;
let camTargetZoom = 1;

// Combo counter per player (who is being combo'd)
const comboState = [
  { count: 0, timer: 0, displayScale: 1, x: 0, y: 0 },
  { count: 0, timer: 0, displayScale: 1, x: 0, y: 0 },
];

// Hit detection labels (floating text)
const hitLabels = []; // { text, x, y, life, maxLife }

// Death explosion state
const deathFlashes = []; // { direction, life, maxLife }

// Jump lines
const jumpLines = []; // { x, y, life, maxLife, offsets[] }

// Previous frame state for transition detection
let prevFrame = null;

// Blast zone flash
let blastFlashDir = ''; // 'left','right','top','bottom'
let blastFlashLife = 0;

function resetJuiceState() {
  playerTrails[0] = [];
  playerTrails[1] = [];
  shakeX = 0; shakeY = 0; shakeMagnitude = 0;
  hitFreezeFrames = 0;
  impactFlashes.length = 0;
  squashState[0] = { scaleX: 1, scaleY: 1, timer: 0, landing: false };
  squashState[1] = { scaleX: 1, scaleY: 1, timer: 0, landing: false };
  comboState[0] = { count: 0, timer: 0, displayScale: 1, x: 0, y: 0 };
  comboState[1] = { count: 0, timer: 0, displayScale: 1, x: 0, y: 0 };
  hitLabels.length = 0;
  deathFlashes.length = 0;
  jumpLines.length = 0;
  prevFrame = null;
  blastFlashDir = '';
  blastFlashLife = 0;
  clearAllParticles();
  camCenterX = 0; camCenterY = 30;
  camZoom = 1;
  camTargetCenterX = 0; camTargetCenterY = 30;
  camTargetZoom = 1;
}


// =====================================================================
// TRANSITION DETECTION + JUICE TRIGGERS
// =====================================================================

function detectTransitionsAndTriggerJuice(frame) {
  if (!prevFrame) { prevFrame = frame; return; }

  const prev = prevFrame;
  const cur = frame;

  for (let idx = 0; idx < 2; idx++) {
    const cp = cur.players[idx];
    const pp = prev.players[idx];
    const other = cur.players[1 - idx];
    const otherPrev = prev.players[1 - idx];

    // --- HIT DETECTION ---
    // Primary: knockback velocity spikes from ~0 to nonzero
    const prevKB = Math.sqrt(pp.speed_attack_x ** 2 + pp.speed_attack_y ** 2);
    const curKB = Math.sqrt(cp.speed_attack_x ** 2 + cp.speed_attack_y ** 2);
    const hitlagStarted = cp.hitlag > 0 && pp.hitlag === 0;
    const kbHit = curKB > 0.5 && prevKB < 0.2;

    // Fallback: percent increased AND entered a damage action state (75-93)
    // This works even when knockback/hitlag fields are zeroed (old parquet schema)
    const pctDelta = cp.percent - pp.percent;
    const inDamage = cp.action_state >= 75 && cp.action_state <= 93;
    const wasNotDamage = pp.action_state < 75 || pp.action_state > 93;
    const pctHit = pctDelta > 0 && inDamage && wasNotDamage;

    if (kbHit || hitlagStarted || pctHit) {
      // This player is getting HIT
      const attacker = other;
      const attackerPrev = otherPrev;

      // Impact point: midpoint between players
      const impX = (cp.x + attacker.x) / 2;
      const impY = (cp.y + attacker.y) / 2;

      // Screen shake proportional to knockback (or percent delta as fallback)
      const kb = curKB > 0.5 ? curKB : Math.max(pctDelta * 0.3, 1);
      shakeMagnitude = Math.min(kb * 3, 15);

      // Impact flash
      impactFlashes.push({ x: impX, y: impY, life: 6, maxLife: 6 });

      // Spark particles at impact (8-12)
      const sparkCount = 8 + Math.floor(Math.random() * 5);
      const [impSX, impSY] = gameToScreen(impX, impY);
      for (let s = 0; s < sparkCount; s++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 4;
        emitParticle(
          impSX, impSY,
          Math.cos(angle) * speed, Math.sin(angle) * speed,
          10 + Math.floor(Math.random() * 10), // life
          1 + Math.random() * 2, // size
          255, 240, 180, // warm white/yellow
          0.9,
          0.1 // slight gravity
        );
      }

      // Hit detection label: show attacker's action state name
      const attackName = attackDisplayName(attackerPrev.action_state);
      hitLabels.push({
        text: attackName,
        x: impX, y: impY,
        life: 30, maxLife: 30,
      });

      // Combo counter: increment for the attacker (idx 1-idx is the attacker)
      const attackerIdx = 1 - idx;
      const combo = comboState[attackerIdx];
      combo.count++;
      combo.timer = 120; // 2 seconds at 60fps
      combo.displayScale = 1.5; // pop in
      combo.x = attacker.x;
      combo.y = attacker.y;
    }

    // --- HIT FREEZE ---
    if (hitlagStarted || pctHit) {
      hitFreezeFrames = 3;
    }

    // --- LANDING DETECTION ---
    const landed = cp.on_ground && !pp.on_ground;
    if (landed) {
      // Landing dust: 4-6 particles at feet
      const [footX, footY] = gameToScreen(cp.x, STAGE.ground.y);
      const dustCount = 4 + Math.floor(Math.random() * 3);
      for (let d = 0; d < dustCount; d++) {
        const dir = (d % 2 === 0) ? 1 : -1;
        emitParticle(
          footX + (Math.random() - 0.5) * 6,
          footY,
          dir * (0.5 + Math.random() * 1.5),
          -(0.2 + Math.random() * 0.5),
          12 + Math.floor(Math.random() * 6),
          1.5 + Math.random(),
          160, 160, 170,
          0.4,
          0.02
        );
      }

      // Squash on landing
      squashState[idx].landing = true;
      squashState[idx].timer = 4;
      squashState[idx].scaleX = 1.25;
      squashState[idx].scaleY = 0.7;
    }

    // --- JUMP DETECTION ---
    // Fallback: if speed_y is zeroed (old schema), detect via leaving ground + jump action states
    const jumpAction = cp.action_state >= 24 && cp.action_state <= 26; // KneeBend, Jump*, JumpAir*
    const jumped = !cp.on_ground && pp.on_ground && (cp.speed_y > 0 || jumpAction);
    if (jumped) {
      // Jump lines below player
      const lineCount = 2 + Math.floor(Math.random() * 2);
      const offsets = [];
      for (let l = 0; l < lineCount; l++) {
        offsets.push((Math.random() - 0.5) * 10);
      }
      jumpLines.push({
        x: cp.x, y: STAGE.ground.y,
        life: 4, maxLife: 4,
        offsets: offsets,
      });
    }

    // --- DEATH DETECTION ---
    if (cp.stocks < pp.stocks) {
      // Death explosion at last known position
      const [deathSX, deathSY] = gameToScreen(pp.x, pp.y);
      const burstCount = 30 + Math.floor(Math.random() * 11);
      for (let b = 0; b < burstCount; b++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 5;
        const isWhite = Math.random() > 0.4;
        emitParticle(
          deathSX, deathSY,
          Math.cos(angle) * speed, Math.sin(angle) * speed,
          15 + Math.floor(Math.random() * 20),
          2 + Math.random() * 3,
          isWhite ? 255 : 255, isWhite ? 255 : 220, isWhite ? 255 : 100,
          1.0,
          0.05
        );
      }

      // Expanding ring
      impactFlashes.push({ x: pp.x, y: pp.y, life: 12, maxLife: 12, ring: true });

      // Screen shake
      shakeMagnitude = 12;

      // Blast zone flash direction
      if (pp.x < STAGE.blastzone.left + 10) blastFlashDir = 'left';
      else if (pp.x > STAGE.blastzone.right - 10) blastFlashDir = 'right';
      else if (pp.y > STAGE.blastzone.top - 10) blastFlashDir = 'top';
      else blastFlashDir = 'bottom';
      blastFlashLife = 10;
    }
  }

  prevFrame = frame;
}


// =====================================================================
// JUICE UPDATE (called each visual tick)
// =====================================================================

function updateJuice(frame) {
  // Update particles
  updateParticles();
  updateAmbientParticles();

  // Screen shake decay
  if (shakeMagnitude > 0.1) {
    shakeX = (Math.random() - 0.5) * shakeMagnitude * 2;
    shakeY = (Math.random() - 0.5) * shakeMagnitude * 2;
    shakeMagnitude *= 0.7; // exponential decay
  } else {
    shakeX = 0; shakeY = 0; shakeMagnitude = 0;
  }

  // Impact flashes
  for (let i = impactFlashes.length - 1; i >= 0; i--) {
    impactFlashes[i].life--;
    if (impactFlashes[i].life <= 0) impactFlashes.splice(i, 1);
  }

  // Hit labels
  for (let i = hitLabels.length - 1; i >= 0; i--) {
    hitLabels[i].life--;
    if (hitLabels[i].life <= 0) hitLabels.splice(i, 1);
  }

  // Jump lines
  for (let i = jumpLines.length - 1; i >= 0; i--) {
    jumpLines[i].life--;
    if (jumpLines[i].life <= 0) jumpLines.splice(i, 1);
  }

  // Death flashes
  for (let i = deathFlashes.length - 1; i >= 0; i--) {
    deathFlashes[i].life--;
    if (deathFlashes[i].life <= 0) deathFlashes.splice(i, 1);
  }

  // Blast zone flash
  if (blastFlashLife > 0) blastFlashLife--;

  // Squash/stretch
  for (let idx = 0; idx < 2; idx++) {
    const ss = squashState[idx];
    if (ss.timer > 0) {
      ss.timer--;
      if (ss.timer <= 0) {
        ss.scaleX = 1; ss.scaleY = 1; ss.landing = false;
      }
    }

    // Velocity-based stretch (only when not in landing squash)
    if (!ss.landing && frame.players[idx]) {
      const p = frame.players[idx];
      const vx = p.on_ground ? p.speed_ground_x : p.speed_air_x;
      const vy = p.speed_y;
      const speed = Math.sqrt(vx * vx + vy * vy);
      if (speed > 1.0) {
        const stretchFactor = Math.min(speed / 6, 0.3); // max 0.3 extra
        ss.scaleX = 1 - stretchFactor * 0.3;
        ss.scaleY = 1 + stretchFactor;
      } else if (ss.timer <= 0) {
        ss.scaleX = 1; ss.scaleY = 1;
      }
    }
  }

  // Combo counters
  for (let idx = 0; idx < 2; idx++) {
    const combo = comboState[idx];
    if (combo.timer > 0) {
      combo.timer--;
      // Lerp display scale toward 1
      combo.displayScale += (1 - combo.displayScale) * 0.2;
      if (combo.timer <= 0) {
        combo.count = 0;
      }
    }
  }

  // Momentum trails
  if (frame.players) {
    for (let idx = 0; idx < 2; idx++) {
      const p = frame.players[idx];
      playerTrails[idx].push({ x: p.x, y: p.y });
      if (playerTrails[idx].length > TRAIL_LENGTH) {
        playerTrails[idx].shift();
      }
    }
  }

  // Dash dust
  if (frame.players) {
    for (let idx = 0; idx < 2; idx++) {
      const p = frame.players[idx];
      if (p.on_ground && Math.abs(p.speed_ground_x) > 1.5) {
        // Emit dust every 3 frames
        if (Math.random() < 0.35) {
          const [footX, footY] = gameToScreen(p.x, STAGE.ground.y);
          emitParticle(
            footX + (Math.random() - 0.5) * 4,
            footY,
            -p.speed_ground_x * 0.2 + (Math.random() - 0.5) * 0.5,
            -(0.1 + Math.random() * 0.3),
            8 + Math.floor(Math.random() * 5),
            1 + Math.random() * 0.8,
            140, 140, 150,
            0.25,
            0.01
          );
        }
      }
    }
  }

  // Dynamic camera
  if (frame.players) {
    const p0 = frame.players[0];
    const p1 = frame.players[1];
    camTargetCenterX = (p0.x + p1.x) / 2;
    camTargetCenterY = (p0.y + p1.y) / 2 + 20; // bias upward slightly

    const dx = Math.abs(p0.x - p1.x);
    const dy = Math.abs(p0.y - p1.y);
    const dist = Math.sqrt(dx * dx + dy * dy);

    // Zoom based on distance between players
    // Stage width is ~340 game units (view). When players are close, zoom in.
    const stageW = STAGE.camera.right - STAGE.camera.left; // 340
    const needed = Math.max(dx + 80, dy + 60, 120); // minimum viewing area
    camTargetZoom = Math.min(2.0, Math.max(1.0, stageW / needed * 0.75));

    // Lerp camera
    camCenterX += (camTargetCenterX - camCenterX) * 0.08;
    camCenterY += (camTargetCenterY - camCenterY) * 0.08;
    camZoom += (camTargetZoom - camZoom) * 0.06;
  }
}


// =====================================================================
// RENDERER
// =====================================================================

const canvas = document.getElementById('stage');
const canvasArea = document.getElementById('canvasArea');
const ctx = canvas.getContext('2d');
const DPR = window.devicePixelRatio || 1;

let canvasW, canvasH;
let viewLeft, viewRight, viewTop, viewBottom;

function resizeCanvas() {
  const area = document.querySelector('.canvas-area');
  canvasW = area.clientWidth;
  canvasH = area.clientHeight;
  canvas.width = canvasW * DPR;
  canvas.height = canvasH * DPR;
  canvas.style.width = canvasW + 'px';
  canvas.style.height = canvasH + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}

function updateCameraView() {
  // Dynamic camera: compute view bounds from camCenter and camZoom
  const baseHalfW = (STAGE.camera.right - STAGE.camera.left) / 2;
  const baseHalfH = (STAGE.camera.top - STAGE.camera.bottom) / 2;
  const halfW = baseHalfW / camZoom;
  const halfH = baseHalfH / camZoom;
  viewLeft = camCenterX - halfW;
  viewRight = camCenterX + halfW;
  viewTop = camCenterY + halfH;
  viewBottom = camCenterY - halfH;
}

function gameToScreen(gx, gy) {
  const sx = ((gx - viewLeft) / (viewRight - viewLeft)) * canvasW;
  const sy = ((viewTop - gy) / (viewTop - viewBottom)) * canvasH;
  return [sx, sy];
}

function gameScaleX(units) {
  return (units / (viewRight - viewLeft)) * canvasW;
}
function gameScaleY(units) {
  return (units / (viewTop - viewBottom)) * canvasH;
}

function drawCapsule(ctx, p, idx, px, py, col, cat, glowColor, glowRadius, capsuleColor) {
  const capsuleH = gameScaleY(CAPSULE_GAME_H);
  const capsuleW = gameScaleX(CAPSULE_GAME_W);
  const ss = squashState[idx];
  const bodyTop = py - capsuleH;
  const bodyBot = py;

  ctx.save();
  ctx.translate(px, py - capsuleH / 2);
  ctx.scale(ss.scaleX, ss.scaleY);
  ctx.translate(-px, -(py - capsuleH / 2));

  ctx.shadowColor = glowColor;
  ctx.shadowBlur = glowRadius;

  ctx.fillStyle = capsuleColor;
  ctx.beginPath();
  ctx.moveTo(px - capsuleW, bodyTop + capsuleW);
  ctx.arc(px, bodyTop + capsuleW, capsuleW, Math.PI, 0);
  ctx.lineTo(px + capsuleW, bodyBot - capsuleW);
  ctx.arc(px, bodyBot - capsuleW, capsuleW, 0, Math.PI);
  ctx.closePath();
  ctx.fill();

  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;
  ctx.restore();

  const fDir = p.facing ? 1 : -1;
  const triOff = gameScaleX(1);
  const triLen = gameScaleX(2);
  const triHalf = gameScaleY(1.2);
  ctx.fillStyle = capsuleColor;
  ctx.beginPath();
  ctx.moveTo(px + fDir * (capsuleW + triOff), py - capsuleH / 2);
  ctx.lineTo(px + fDir * (capsuleW + triOff + triLen), py - capsuleH / 2 - triHalf);
  ctx.lineTo(px + fDir * (capsuleW + triOff + triLen), py - capsuleH / 2 + triHalf);
  ctx.closePath();
  ctx.fill();

  return { capsuleH, capsuleW, bodyTop, bodyBot };
}

function drawFrame(frame) {
  // Update camera before drawing
  updateCameraView();

  ctx.save();

  // Apply screen shake
  ctx.translate(shakeX, shakeY);

  ctx.clearRect(-20, -20, canvasW + 40, canvasH + 40);

  // -- Ambient background particles --
  drawAmbientParticles(ctx, canvasW, canvasH);

  // -- Blast zone (subtle outline) --
  const [bzl, bzt] = gameToScreen(STAGE.blastzone.left, STAGE.blastzone.top);
  const [bzr, bzb] = gameToScreen(STAGE.blastzone.right, STAGE.blastzone.bottom);
  ctx.strokeStyle = 'rgba(244,63,94,0.1)';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.strokeRect(bzl, bzt, bzr - bzl, bzb - bzt);
  ctx.setLineDash([]);

  // -- Blast zone flash on death --
  if (blastFlashLife > 0) {
    const flashAlpha = (blastFlashLife / 10) * 0.4;
    ctx.globalAlpha = flashAlpha;
    ctx.fillStyle = '#f43f5e';
    const thickness = 8;
    if (blastFlashDir === 'left') {
      ctx.fillRect(bzl - thickness, bzt, thickness * 3, bzb - bzt);
    } else if (blastFlashDir === 'right') {
      ctx.fillRect(bzr - thickness * 2, bzt, thickness * 3, bzb - bzt);
    } else if (blastFlashDir === 'top') {
      ctx.fillRect(bzl, bzt - thickness, bzr - bzl, thickness * 3);
    } else if (blastFlashDir === 'bottom') {
      ctx.fillRect(bzl, bzb - thickness * 2, bzr - bzl, thickness * 3);
    }
    ctx.globalAlpha = 1;
  }

  // -- Stage platform --
  const [sl, sy] = gameToScreen(STAGE.ground.x1, STAGE.ground.y);
  const [sr, _] = gameToScreen(STAGE.ground.x2, STAGE.ground.y);
  const grd = ctx.createLinearGradient(sl, sy - 20, sl, sy + 8);
  grd.addColorStop(0, 'transparent');
  grd.addColorStop(0.7, 'rgba(255,255,255,0.03)');
  grd.addColorStop(1, 'rgba(255,255,255,0.06)');
  ctx.fillStyle = grd;
  ctx.fillRect(sl, sy - 20, sr - sl, 28);
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(sl, sy);
  ctx.lineTo(sr, sy);
  ctx.stroke();
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(sl, sy); ctx.lineTo(sl, sy + 60);
  ctx.moveTo(sr, sy); ctx.lineTo(sr, sy + 60);
  ctx.stroke();

  // -- Grid lines (subtle) --
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for (let gx = -150; gx <= 150; gx += 50) {
    const [sx] = gameToScreen(gx, 0);
    ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, canvasH); ctx.stroke();
  }
  for (let gy = -100; gy <= 100; gy += 50) {
    const [, sy2] = gameToScreen(0, gy);
    ctx.beginPath(); ctx.moveTo(0, sy2); ctx.lineTo(canvasW, sy2); ctx.stroke();
  }

  // -- Center marker --
  const [cx, cy] = gameToScreen(0, 0);
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.beginPath();
  ctx.moveTo(cx - 4, cy); ctx.lineTo(cx + 4, cy);
  ctx.moveTo(cx, cy - 4); ctx.lineTo(cx, cy + 4);
  ctx.stroke();

  // -- Jump lines --
  for (const jl of jumpLines) {
    const t = jl.life / jl.maxLife;
    ctx.globalAlpha = t * 0.6;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1.5;
    for (const off of jl.offsets) {
      const [jx, jy] = gameToScreen(jl.x + off, jl.y);
      ctx.beginPath();
      ctx.moveTo(jx, jy);
      ctx.lineTo(jx, jy + 12 * t);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // -- Draw players --
  const colors = [
    { main: '#22c55e', glow: 'rgba(34,197,94,0.35)', dim: 'rgba(34,197,94,0.15)', r: 34, g: 197, b: 94 },
    { main: '#f59e0b', glow: 'rgba(245,158,11,0.35)', dim: 'rgba(245,158,11,0.15)', r: 245, g: 158, b: 11 },
  ];

  frame.players.forEach((p, idx) => {
    const col = colors[idx];
    const [px, py] = gameToScreen(p.x, p.y);
    const cat = actionCategory(p.action_state);
    const catColor = CATEGORY_COLORS[cat];
    const pxPerUnit = canvasW / (viewRight - viewLeft);

    // ========= MOMENTUM TRAILS =========
    const trail = playerTrails[idx];
    if (trail.length > 1) {
      for (let ti = 0; ti < trail.length - 1; ti++) {
        const frac = ti / trail.length;
        const alpha = frac * 0.25; // oldest ~ 0, newest ~ 0.25
        const tp = trail[ti];
        const [tx, ty] = gameToScreen(tp.x, tp.y);

        ctx.globalAlpha = alpha;
        ctx.fillStyle = col.main;
        // Draw a mini capsule at trail position (game-unit scaled)
        const cH = gameScaleY(CAPSULE_GAME_H * (0.5 + frac * 0.5));
        const cW = gameScaleX(CAPSULE_GAME_W * (0.5 + frac * 0.5));
        ctx.beginPath();
        ctx.moveTo(tx - cW, ty - cH + cW);
        ctx.arc(tx, ty - cH + cW, cW, Math.PI, 0);
        ctx.lineTo(tx + cW, ty - cW);
        ctx.arc(tx, ty - cW, cW, 0, Math.PI);
        ctx.closePath();
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // -- Shadow / ground indicator --
    if (!p.on_ground && p.x >= STAGE.ground.x1 && p.x <= STAGE.ground.x2) {
      const [, groundY] = gameToScreen(p.x, STAGE.ground.y);
      ctx.strokeStyle = col.dim;
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(px, py); ctx.lineTo(px, groundY);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = col.dim;
      const shadowW = gameScaleX(3);
      const shadowH = gameScaleY(0.8);
      ctx.beginPath();
      ctx.ellipse(px, groundY, shadowW, shadowH, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // -- Velocity arrow (self velocity) --
    // Arrow scale: velocity in game units/frame â†’ screen pixels via gameScale
    const vx = p.on_ground ? p.speed_ground_x : p.speed_air_x;
    const vy = p.speed_y;
    const vMag = Math.sqrt(vx * vx + vy * vy);
    if (vMag > 0.3) {
      const ax = px + gameScaleX(vx * 3);
      const ay = py - gameScaleY(vy * 3);
      ctx.strokeStyle = 'rgba(6,182,212,0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(ax, ay);
      ctx.stroke();
      const angle = Math.atan2(ay - py, ax - px);
      const arrowHead = Math.max(4, gameScaleX(1.5));
      ctx.fillStyle = 'rgba(6,182,212,0.6)';
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(ax - arrowHead * Math.cos(angle - 0.4), ay - arrowHead * Math.sin(angle - 0.4));
      ctx.lineTo(ax - arrowHead * Math.cos(angle + 0.4), ay - arrowHead * Math.sin(angle + 0.4));
      ctx.fill();
    }

    // -- Knockback arrow --
    const kMag = Math.sqrt(p.speed_attack_x ** 2 + p.speed_attack_y ** 2);
    if (kMag > 0.3) {
      const kx = px + gameScaleX(p.speed_attack_x * 3);
      const ky = py - gameScaleY(p.speed_attack_y * 3);
      ctx.strokeStyle = 'rgba(244,63,94,0.7)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(kx, ky);
      ctx.stroke();
      const angle = Math.atan2(ky - py, kx - px);
      const arrowHead = Math.max(4, gameScaleX(1.5));
      ctx.fillStyle = 'rgba(244,63,94,0.7)';
      ctx.beginPath();
      ctx.moveTo(kx, ky);
      ctx.lineTo(kx - arrowHead * Math.cos(angle - 0.4), ky - arrowHead * Math.sin(angle - 0.4));
      ctx.lineTo(kx - arrowHead * Math.cos(angle + 0.4), ky - arrowHead * Math.sin(angle + 0.4));
      ctx.fill();
    }

    // -- Shield bubble --
    if (p.action_state >= 178 && p.action_state <= 182) {
      const shieldRad = gameScaleY(5 + (p.shield_strength / 60) * 4);
      ctx.strokeStyle = col.glow;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.4 + (p.shield_strength / 60) * 0.4;
      ctx.beginPath();
      ctx.arc(px, py - gameScaleY(2), shieldRad, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = col.dim;
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // ========= PERCENT HEAT GLOW =========
    const pct = p.percent;
    let glowColor = col.glow;
    let glowRadius = cat === 'attack' ? 16 : (cat === 'damage' ? 12 : 8);
    let capsuleColor = col.main;
    let pulseMultiplier = 1;

    if (pct > 120) {
      // Red, strong pulsing glow, brighter capsule
      const pulse = 1 + Math.sin(performance.now() * 0.008) * 0.3;
      pulseMultiplier = pulse;
      glowColor = `rgba(244, 63, 94, ${0.6 * pulse})`;
      glowRadius = Math.max(glowRadius, 20) * pulse;
      // Brighten the capsule
      const brightness = 1 + (pct - 120) / 200;
      capsuleColor = `rgb(${Math.min(255, Math.round(col.r * brightness))}, ${Math.min(255, Math.round(col.g * 0.6))}, ${Math.min(255, Math.round(col.b * 0.5))})`;
    } else if (pct > 80) {
      // Orange tint, pulsing glow
      const pulse = 1 + Math.sin(performance.now() * 0.006) * 0.15;
      pulseMultiplier = pulse;
      const t = (pct - 80) / 40;
      glowColor = `rgba(${Math.round(245 * t + col.r * (1-t))}, ${Math.round(120 * t + col.g * (1-t))}, ${Math.round(30 * t + col.b * (1-t))}, ${0.45 * pulse})`;
      glowRadius = Math.max(glowRadius, 14) * pulse;
    } else if (pct > 30) {
      // Slightly warmer, increased glow
      const t = (pct - 30) / 50;
      glowColor = `rgba(${Math.round(col.r + (50 * t))}, ${Math.round(col.g * (1 - t * 0.2))}, ${Math.round(col.b * (1 - t * 0.3))}, 0.4)`;
      glowRadius = Math.max(glowRadius, 10 + t * 4);
    }

    let drewCharacter = false;
    let capsuleGeom = null;
    if (renderMode === 'character') {
      drewCharacter = drawCharacter(ctx, p, px, py, pxPerUnit, col);
    }
    if (!drewCharacter) {
      capsuleGeom = drawCapsule(ctx, p, idx, px, py, col, cat, glowColor, glowRadius, capsuleColor);
    }

    // -- Hitlag flash --
    if (p.hitlag > 0) {
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 2;
      const flashR = drewCharacter
        ? (28 + p.hitlag * 2)
        : (capsuleGeom.capsuleH * 0.8 + p.hitlag * gameScaleY(1));
      const flashCenterY = drewCharacter ? (py - pxPerUnit * 5) : (py - capsuleGeom.capsuleH / 2);
      ctx.beginPath();
      ctx.arc(px, flashCenterY, flashR, 0, Math.PI * 2);
      ctx.stroke();
    }

    // -- Damage state visual --
    if (cat === 'damage') {
      ctx.strokeStyle = 'rgba(245,158,11,0.4)';
      ctx.lineWidth = 1;
      const sparkCenterY = drewCharacter ? (py - pxPerUnit * 5) : (py - capsuleGeom.capsuleH / 2);
      const sparkSpreadX = drewCharacter ? Math.max(18, pxPerUnit * 8) : (capsuleGeom.capsuleW * 4);
      const sparkSpreadY = drewCharacter ? Math.max(10, pxPerUnit * 4) : capsuleGeom.capsuleH;
      for (let s = 0; s < 3; s++) {
        const sparkX = px + (Math.random() - 0.5) * sparkSpreadX;
        const sparkY = sparkCenterY + (Math.random() - 0.5) * sparkSpreadY;
        const sparkLen = Math.max(2, gameScaleX(1));
        ctx.beginPath();
        ctx.moveTo(sparkX - sparkLen, sparkY);
        ctx.lineTo(sparkX + sparkLen, sparkY);
        ctx.stroke();
      }
    }

    // -- Player label --
    ctx.fillStyle = col.main;
    ctx.font = '600 10px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`P${idx + 1}`, px, drewCharacter ? (py - pxPerUnit * 12) : (capsuleGeom.bodyTop - 4));

    // -- Action state label (color-coded by category) --
    const actionLabel = actionName(p.action_state);
    ctx.fillStyle = catColor;
    ctx.font = '500 9px monospace';
    ctx.fillText(actionLabel, px, (drewCharacter ? py : capsuleGeom.bodyBot) + 12);

    // -- Percent near player --
    ctx.fillStyle = p.percent > 100 ? '#f43f5e' : (p.percent > 60 ? '#f59e0b' : 'rgba(255,255,255,0.7)');
    ctx.font = '700 11px monospace';
    ctx.fillText(`${Math.round(p.percent)}%`, px, (drewCharacter ? py : capsuleGeom.bodyBot) + 24);
  });

  // ========= IMPACT FLASHES (starburst + ring) =========
  for (const flash of impactFlashes) {
    const t = flash.life / flash.maxLife;
    const [fx, fy] = gameToScreen(flash.x, flash.y);

    if (flash.ring) {
      // Death ring: expanding circle
      const radius = (1 - t) * 80;
      ctx.globalAlpha = t * 0.7;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3 * t;
      ctx.beginPath();
      ctx.arc(fx, fy, radius, 0, Math.PI * 2);
      ctx.stroke();
    } else {
      // Hit starburst
      const radius = (1 - t) * 30 + 5;
      ctx.globalAlpha = t * 0.9;

      // White center
      const starGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, radius);
      starGrad.addColorStop(0, 'rgba(255,255,255,0.9)');
      starGrad.addColorStop(0.3, 'rgba(255,255,200,0.6)');
      starGrad.addColorStop(1, 'rgba(255,255,200,0)');
      ctx.fillStyle = starGrad;
      ctx.beginPath();
      ctx.arc(fx, fy, radius, 0, Math.PI * 2);
      ctx.fill();

      // Star spikes
      ctx.strokeStyle = `rgba(255, 255, 220, ${t * 0.7})`;
      ctx.lineWidth = 2 * t;
      const spikeCount = 6;
      for (let s = 0; s < spikeCount; s++) {
        const angle = (s / spikeCount) * Math.PI * 2 + (1 - t) * 0.5;
        const spikeLen = radius * 1.5;
        ctx.beginPath();
        ctx.moveTo(fx, fy);
        ctx.lineTo(fx + Math.cos(angle) * spikeLen, fy + Math.sin(angle) * spikeLen);
        ctx.stroke();
      }
    }
    ctx.globalAlpha = 1;
  }

  // ========= HIT LABELS (floating text) =========
  for (const hl of hitLabels) {
    const t = hl.life / hl.maxLife;
    const [hx, hy] = gameToScreen(hl.x, hl.y);
    const drift = (1 - t) * 30;
    ctx.globalAlpha = t;
    ctx.fillStyle = '#ffffff';
    ctx.font = '700 13px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(hl.text, hx, hy - 20 - drift);
    ctx.globalAlpha = 1;
  }

  // ========= COMBO COUNTERS =========
  for (let idx = 0; idx < 2; idx++) {
    const combo = comboState[idx];
    if (combo.count >= 2 && combo.timer > 0) {
      const col = colors[idx];
      const p = frame.players[idx];
      const [cx, cy] = gameToScreen(p.x, p.y);
      const fadeAlpha = Math.min(1, combo.timer / 20);
      const scale = combo.displayScale;

      ctx.save();
      ctx.translate(cx, cy - 50);
      ctx.scale(scale, scale);
      ctx.globalAlpha = fadeAlpha;

      // Background pill
      const text = `${combo.count} HIT`;
      ctx.font = '800 14px monospace';
      const textW = ctx.measureText(text).width;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      const pillW = textW + 16;
      const pillH = 22;
      ctx.beginPath();
      ctx.roundRect(-pillW/2, -pillH/2, pillW, pillH, 4);
      ctx.fill();

      // Text
      ctx.fillStyle = col.main;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, 0, 0);

      ctx.restore();
      ctx.globalAlpha = 1;
    }
  }

  // ========= PARTICLES (sparks, dust, death burst) =========
  drawParticles(ctx);

  // -- Legend --
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.font = '10px monospace';
  ctx.textAlign = 'left';
  ctx.fillText('cyan arrow = velocity', 10, canvasH - 30);
  ctx.fillText('red arrow = knockback', 10, canvasH - 16);

  // Axis labels
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.font = '9px monospace';
  ctx.textAlign = 'center';
  const [l0] = gameToScreen(-100, 0);
  const [l1] = gameToScreen(0, 0);
  const [l2] = gameToScreen(100, 0);
  ctx.fillText('-100', l0, canvasH - 4);
  ctx.fillText('0', l1, canvasH - 4);
  ctx.fillText('100', l2, canvasH - 4);

  ctx.restore(); // undo shake translation
}

function drawCanvasMessage(message) {
  if (!message) return;
  ctx.save();
  ctx.fillStyle = 'rgba(10,10,15,0.72)';
  ctx.fillRect(0, 0, canvasW, canvasH);

  const pad = 16;
  const boxW = Math.min(640, canvasW - 24);
  const lineH = 18;
  const title = 'Load Error';
  const lines = wrapCanvasText(message, boxW - pad * 2, '12px monospace');
  const boxH = 56 + (lines.length * lineH);
  const boxX = (canvasW - boxW) / 2;
  const boxY = Math.max(20, (canvasH - boxH) / 2);

  ctx.fillStyle = 'rgba(17,24,39,0.96)';
  ctx.strokeStyle = 'rgba(244,63,94,0.4)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.rect(boxX, boxY, boxW, boxH);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = '#f43f5e';
  ctx.font = '700 12px monospace';
  ctx.textAlign = 'left';
  ctx.fillText(title, boxX + pad, boxY + 22);

  ctx.fillStyle = 'rgba(226,232,240,0.9)';
  ctx.font = '12px monospace';
  lines.forEach((line, i) => {
    ctx.fillText(line, boxX + pad, boxY + 46 + i * lineH);
  });
  ctx.restore();
}

function wrapCanvasText(text, maxWidth, font) {
  ctx.save();
  ctx.font = font;
  const words = String(text).split(/\s+/);
  const lines = [];
  let current = '';
  for (const word of words) {
    const next = current ? `${current} ${word}` : word;
    if (ctx.measureText(next).width <= maxWidth || !current) {
      current = next;
    } else {
      lines.push(current);
      current = word;
    }
  }
  if (current) lines.push(current);
  ctx.restore();
  return lines.length ? lines : ['Unknown error'];
}


// =====================================================================
// UI UPDATE
// =====================================================================

function updatePanel(frame) {
  frame.players.forEach((p, idx) => {
    const n = idx + 1;
    const charName = CHARACTERS[p.character] || `Char_${p.character}`;
    document.getElementById(`p${n}Char`).textContent = charName;
    const pctEl = document.getElementById(`p${n}Pct`);
    pctEl.textContent = `${Math.round(p.percent)}%`;
    pctEl.classList.toggle('high', p.percent > 100);

    document.getElementById(`p${n}Action`).textContent = `${actionName(p.action_state)} (${p.action_state})`;
    document.getElementById(`p${n}Pos`).textContent = `${p.x.toFixed(1)}, ${p.y.toFixed(1)}`;
    const vx = p.on_ground ? p.speed_ground_x : p.speed_air_x;
    document.getElementById(`p${n}Vel`).textContent = `${vx.toFixed(2)}, ${p.speed_y.toFixed(2)}`;
    document.getElementById(`p${n}Face`).textContent = p.facing ? 'Right' : 'Left';
    document.getElementById(`p${n}Air`).textContent = p.on_ground ? 'No' : 'Yes';
    document.getElementById(`p${n}Shield`).textContent = p.shield_strength.toFixed(1);
    document.getElementById(`p${n}Jumps`).textContent = p.jumps_left;
    document.getElementById(`p${n}StateAge`).textContent = p.state_age;
    document.getElementById(`p${n}Hitlag`).textContent = p.hitlag || 0;

    const stocksEl = document.getElementById(`p${n}Stocks`);
    stocksEl.innerHTML = '';
    for (let s = 0; s < 4; s++) {
      const pip = document.createElement('div');
      pip.className = `stock-pip ${s < p.stocks ? 'alive' : 'dead'} p${n}`;
      stocksEl.appendChild(pip);
    }
  });

  const inspEl = document.getElementById('inspector');
  let html = '';
  frame.players.forEach((p, idx) => {
    html += `<div style="margin-bottom:6px;color:${idx === 0 ? 'var(--p1)' : 'var(--p2)'};font-weight:600">P${idx+1}</div>`;
    for (const [k, v] of Object.entries(p)) {
      const val = typeof v === 'number' ? (Number.isInteger(v) ? v : v.toFixed(3)) : v;
      html += `<span class="key">${k}</span>: <span class="val">${val}</span><br>`;
    }
    html += '<br>';
  });
  html += `<span class="key">stage</span>: <span class="val">${frame.stage}</span>`;
  inspEl.innerHTML = html;
}


// =====================================================================
// PLAYBACK ENGINE
// =====================================================================

let frames = [];
let loadedFrames = null;
let loadedFileName = '';
let currentFrame = 0;
let playing = false;
let playSpeed = 1;
const SPEEDS = [0.1, 0.25, 0.5, 1, 2, 4];
let speedIdx = 3;
let lastFrameTime = 0;
let animId = null;
let canvasErrorMessage = '';

const timeline = document.getElementById('timeline');
const frameNum = document.getElementById('frameNum');
const totalFrames = document.getElementById('totalFrames');
const btnPlay = document.getElementById('btnPlay');
const btnSpeed = document.getElementById('btnSpeed');
const speedLabel = document.getElementById('speedLabel');
const dataSource = document.getElementById('dataSource');
const dataTag = document.getElementById('dataTag');
const btnLoadFile = document.getElementById('btnLoadFile');
const fileInput = document.getElementById('fileInput');
const btnRenderMode = document.getElementById('btnRenderMode');

function preloadCharacterAnimationsForCurrentData() {
  if (renderMode !== 'character' || !fflateAvailable || !frames.length) return;
  const charIds = new Set();
  const seedFrame = frames[Math.min(currentFrame, frames.length - 1)] || frames[0];
  if (!seedFrame || !seedFrame.players) return;
  for (const p of seedFrame.players) charIds.add(p.character);
  Promise.all([...charIds].map(loadCharAnimations))
    .then(() => renderCurrentFrame())
    .catch((err) => console.error('[anim] preload failed:', err));
}

function setCanvasError(message) {
  canvasErrorMessage = message || '';
  renderCurrentFrame();
}

function clearCanvasError() {
  if (!canvasErrorMessage) return;
  canvasErrorMessage = '';
  renderCurrentFrame();
}

function setHeaderTag(kind) {
  const isLoaded = kind === 'loaded';
  dataTag.textContent = isLoaded ? 'Model Output' : 'Mock Data';
  dataTag.style.background = isLoaded ? 'var(--p2-dim)' : 'var(--p1-dim)';
  dataTag.style.color = isLoaded ? 'var(--p2)' : 'var(--p1)';
  dataTag.style.borderColor = isLoaded ? 'rgba(245,158,11,0.25)' : 'rgba(34,197,94,0.2)';
}

function ensureLoadedOption() {
  let option = dataSource.querySelector('option[value="loaded"]');
  if (!option) {
    option = document.createElement('option');
    option.value = 'loaded';
    option.textContent = 'Loaded file';
    dataSource.appendChild(option);
  }
  return option;
}

function resetPlaybackWithFrames(nextFrames) {
  frames = nextFrames;
  currentFrame = 0;
  timeline.max = Math.max(0, frames.length - 1);
  timeline.value = 0;
  totalFrames.textContent = frames.length;
  resetJuiceState();
  renderCurrentFrame();
  preloadCharacterAnimationsForCurrentData();
}

function loadScenario(name) {
  setHeaderTag('mock');
  canvasErrorMessage = '';
  resetPlaybackWithFrames(generateMockData(name));
}

function loadLoadedFrames() {
  if (!loadedFrames) {
    setCanvasError('No file has been loaded yet.');
    return;
  }
  setHeaderTag('loaded');
  canvasErrorMessage = '';
  resetPlaybackWithFrames(loadedFrames);
}

function validateAndNormalizeLoadedFrames(data) {
  if (!Array.isArray(data)) {
    throw new Error('Top-level JSON must be an array of frame objects.');
  }
  if (data.length === 0) {
    throw new Error('JSON array is empty. Expected at least 1 frame.');
  }
  if (typeof data[0] !== 'object' || data[0] === null || Array.isArray(data[0])) {
    throw new Error('First array entry must be a frame object.');
  }
  if (!Array.isArray(data[0].players) || data[0].players.length !== 2) {
    throw new Error('First frame must include a players array with exactly 2 entries.');
  }
  const firstPlayer = data[0].players[0];
  if (!firstPlayer || typeof firstPlayer !== 'object') {
    throw new Error('First player in first frame must be an object.');
  }
  for (const key of ['x', 'y', 'action_state']) {
    if (!(key in firstPlayer)) {
      throw new Error(`First player in first frame is missing required field "${key}".`);
    }
    if (!Number.isFinite(Number(firstPlayer[key]))) {
      throw new Error(`First player field "${key}" must be numeric.`);
    }
  }

  const playerDefaults = {
    x: 0, y: 0, percent: 0, shield_strength: 60,
    speed_air_x: 0, speed_y: 0, speed_ground_x: 0,
    speed_attack_x: 0, speed_attack_y: 0,
    state_age: 0, hitlag: 0, stocks: 4,
    facing: 1, on_ground: 1, action_state: 14,
    jumps_left: 2, character: 0,
  };

  return data.map((frame, frameIdx) => {
    if (typeof frame !== 'object' || frame === null || Array.isArray(frame)) {
      throw new Error(`Frame ${frameIdx} is not an object.`);
    }
    const requiredFrameKeys = ['players'];
    for (const key of requiredFrameKeys) {
      if (!(key in frame)) throw new Error(`Frame ${frameIdx} is missing "${key}".`);
    }
    if (!Array.isArray(frame.players) || frame.players.length !== 2) {
      throw new Error(`Frame ${frameIdx} must have a players array with 2 entries.`);
    }
    const players = frame.players.map((player, playerIdx) => {
      if (typeof player !== 'object' || player === null || Array.isArray(player)) {
        throw new Error(`Frame ${frameIdx} player ${playerIdx + 1} is not an object.`);
      }
      const merged = { ...playerDefaults, ...player };
      for (const numericKey of Object.keys(playerDefaults)) {
        const num = Number(merged[numericKey]);
        if (!Number.isFinite(num)) {
          throw new Error(`Frame ${frameIdx} player ${playerIdx + 1} field "${numericKey}" must be numeric.`);
        }
        merged[numericKey] = num;
      }
      merged.facing = merged.facing ? 1 : 0;
      merged.on_ground = merged.on_ground ? 1 : 0;
      return merged;
    });
    return { players, stage: Number.isFinite(Number(frame.stage)) ? Number(frame.stage) : 31 };
  });
}

async function loadJsonFile(file) {
  if (!file) return;
  try {
    const text = await file.text();
    const parsed = JSON.parse(text);
    const normalized = validateAndNormalizeLoadedFrames(parsed);
    loadedFrames = normalized;
    loadedFileName = file.name || '';
    const loadedOption = ensureLoadedOption();
    loadedOption.textContent = 'Loaded file';
    loadedOption.title = loadedFileName;
    dataSource.value = 'loaded';
    if (playing) togglePlay();
    loadLoadedFrames();
  } catch (err) {
    const msg = err && err.message ? err.message : String(err);
    setCanvasError(msg);
  }
}

function readFirstDroppedFile(event) {
  const files = event.dataTransfer && event.dataTransfer.files;
  return files && files.length ? files[0] : null;
}

function renderCurrentFrame() {
  if (!frames.length) return;
  const frame = frames[currentFrame];
  drawFrame(frame);
  if (canvasErrorMessage) drawCanvasMessage(canvasErrorMessage);
  updatePanel(frame);
  frameNum.textContent = currentFrame;
  timeline.value = currentFrame;
}

function tick(ts) {
  if (!playing) return;

  // Hit freeze: skip tick updates for N real frames
  if (hitFreezeFrames > 0) {
    hitFreezeFrames--;
    // Still update visual-only juice (particles, shake, flashes decay)
    if (frames.length) {
      updateJuice(frames[currentFrame]);
      drawFrame(frames[currentFrame]);
      if (canvasErrorMessage) drawCanvasMessage(canvasErrorMessage);
    }
    animId = requestAnimationFrame(tick);
    return;
  }

  const dt = ts - lastFrameTime;
  const frameInterval = 1000 / (60 * playSpeed);
  if (dt >= frameInterval) {
    lastFrameTime = ts - (dt % frameInterval);
    currentFrame++;
    if (currentFrame >= frames.length) {
      currentFrame = 0;
      resetJuiceState();
    }
    const frame = frames[currentFrame];

    // Detect transitions and trigger juice effects
    detectTransitionsAndTriggerJuice(frame);

    // Update all juice systems
    updateJuice(frame);

    // Render
    drawFrame(frame);
    if (canvasErrorMessage) drawCanvasMessage(canvasErrorMessage);
    updatePanel(frame);
    frameNum.textContent = currentFrame;
    timeline.value = currentFrame;
  }
  animId = requestAnimationFrame(tick);
}

function togglePlay() {
  playing = !playing;
  btnPlay.textContent = playing ? '\u23F8' : '\u25B6';
  btnPlay.classList.toggle('active', playing);
  if (playing) {
    lastFrameTime = performance.now();
    animId = requestAnimationFrame(tick);
  } else if (animId) {
    cancelAnimationFrame(animId);
  }
}

function stepFrame(delta) {
  if (playing) togglePlay();
  const newFrame = Math.max(0, Math.min(frames.length - 1, currentFrame + delta));

  // When stepping, we still want juice transitions
  // Walk through each intermediate frame to detect transitions
  if (delta > 0) {
    for (let f = currentFrame + 1; f <= newFrame; f++) {
      detectTransitionsAndTriggerJuice(frames[f]);
      updateJuice(frames[f]);
    }
  } else if (delta < 0) {
    // Stepping backward: reset prevFrame to the frame before destination
    if (newFrame > 0) {
      prevFrame = frames[newFrame - 1];
    } else {
      prevFrame = null;
    }
    // Clear transient effects when stepping back
    playerTrails[0] = [];
    playerTrails[1] = [];
  }

  currentFrame = newFrame;
  renderCurrentFrame();
}

function cycleSpeed() {
  speedIdx = (speedIdx + 1) % SPEEDS.length;
  playSpeed = SPEEDS[speedIdx];
  btnSpeed.textContent = playSpeed < 1 ? `${playSpeed}x` : `${playSpeed}x`;
  speedLabel.textContent = `${Math.round(60 * playSpeed)} fps`;
}

// -- Event listeners --
btnPlay.addEventListener('click', togglePlay);
document.getElementById('btnPrevFrame').addEventListener('click', () => stepFrame(-1));
document.getElementById('btnNextFrame').addEventListener('click', () => stepFrame(1));
btnSpeed.addEventListener('click', cycleSpeed);

timeline.addEventListener('input', () => {
  const target = parseInt(timeline.value);
  // Reset juice state when scrubbing
  resetJuiceState();
  // Set prevFrame to one before target for transition detection
  if (target > 0) {
    prevFrame = frames[target - 1];
  }
  currentFrame = target;
  // Seed the trails with a few frames before current
  const trailStart = Math.max(0, target - TRAIL_LENGTH);
  for (let f = trailStart; f <= target; f++) {
    const fr = frames[f];
    if (fr) {
      for (let idx = 0; idx < 2; idx++) {
        playerTrails[idx].push({ x: fr.players[idx].x, y: fr.players[idx].y });
        if (playerTrails[idx].length > TRAIL_LENGTH) playerTrails[idx].shift();
      }
    }
  }
  // Update camera immediately for scrub
  if (frames[target]) {
    const p0 = frames[target].players[0];
    const p1 = frames[target].players[1];
    camCenterX = (p0.x + p1.x) / 2;
    camCenterY = (p0.y + p1.y) / 2 + 20;
    camTargetCenterX = camCenterX;
    camTargetCenterY = camCenterY;
    const dx = Math.abs(p0.x - p1.x);
    const dy = Math.abs(p0.y - p1.y);
    const stageW = STAGE.camera.right - STAGE.camera.left;
    const needed = Math.max(dx + 80, dy + 60, 120);
    camZoom = Math.min(2.0, Math.max(1.0, stageW / needed * 0.75));
    camTargetZoom = camZoom;
  }
  renderCurrentFrame();
});

dataSource.addEventListener('change', () => {
  if (playing) togglePlay();
  if (dataSource.value === 'loaded') {
    loadLoadedFrames();
    return;
  }
  loadScenario(dataSource.value);
});

btnLoadFile.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', () => {
  const file = fileInput.files && fileInput.files[0];
  loadJsonFile(file);
  fileInput.value = '';
});

['dragenter', 'dragover'].forEach((eventName) => {
  canvasArea.addEventListener(eventName, (e) => {
    e.preventDefault();
    canvasArea.classList.add('drag-over');
  });
});
canvasArea.addEventListener('dragleave', (e) => {
  e.preventDefault();
  if (!canvasArea.contains(e.relatedTarget)) {
    canvasArea.classList.remove('drag-over');
  }
});
canvasArea.addEventListener('drop', (e) => {
  e.preventDefault();
  canvasArea.classList.remove('drag-over');
  const file = readFirstDroppedFile(e);
  loadJsonFile(file);
});

// Keyboard controls
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
  switch (e.key) {
    case ' ': e.preventDefault(); togglePlay(); break;
    case 'ArrowLeft': e.preventDefault(); stepFrame(e.shiftKey ? -10 : -1); break;
    case 'ArrowRight': e.preventDefault(); stepFrame(e.shiftKey ? 10 : 1); break;
    case '+': case '=': cycleSpeed(); break;
    case '-': case '_':
      speedIdx = (speedIdx - 1 + SPEEDS.length) % SPEEDS.length;
      playSpeed = SPEEDS[speedIdx];
      btnSpeed.textContent = `${playSpeed}x`;
      speedLabel.textContent = `${Math.round(60 * playSpeed)} fps`;
      break;
    case 'c': case 'C':
      toggleRenderMode();
      break;
  }
});

async function toggleRenderMode() {
  if (!fflateAvailable) {
    console.warn('[anim] fflate not available - character mode disabled');
    return;
  }

  if (renderMode === 'capsule') {
    btnRenderMode.textContent = 'Loading...';
    btnRenderMode.classList.add('loading');

    const charIds = new Set();
    if (frames.length) {
      const frame = frames[currentFrame] || frames[0];
      if (frame && frame.players) {
        for (const p of frame.players) charIds.add(p.character);
      }
    }

    try {
      await Promise.all([...charIds].map(loadCharAnimations));
    } catch (err) {
      console.error('[anim] Failed to load animations:', err);
    }

    renderMode = 'character';
    btnRenderMode.textContent = 'Character';
    btnRenderMode.classList.remove('loading');
    btnRenderMode.classList.add('active');
    renderCurrentFrame();
    return;
  }

  renderMode = 'capsule';
  btnRenderMode.textContent = 'Capsule';
  btnRenderMode.classList.remove('loading');
  btnRenderMode.classList.remove('active');
  renderCurrentFrame();
}

btnRenderMode.addEventListener('click', toggleRenderMode);

if (!fflateAvailable) {
  btnRenderMode.disabled = true;
  btnRenderMode.title = 'fflate CDN unavailable';
  btnRenderMode.style.opacity = '0.4';
}

// -- Resize --
window.addEventListener('resize', () => {
  resizeCanvas();
  renderCurrentFrame();
});

// -- Init --
resizeCanvas();
loadScenario('neutral');
</script>
</body>
</html>
